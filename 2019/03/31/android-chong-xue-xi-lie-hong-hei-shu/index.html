<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Android重学系列 红黑树, Android | Linux | Flutter">
    <meta name="description" content="背景红黑树，是一个比较复杂的数据结构。让我们分析一下，整个AVL树的性质。AVL最明显的特点就是，每个节点左右子树的高度差不超过1。那么就会势必产生这样的性质：当插入一个新的节点的时候时间复杂度是O(LogN)还有没有办法更快的？因此红黑树">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Android重学系列 红黑树 | yjy239的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">yjy239的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right nav-menu">
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/" class="waves-effect waves-light">
						
						<i class="fa fa-home"></i>
						
						<span>首页</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/tags" class="waves-effect waves-light">
						
						<i class="fa fa-tags"></i>
						
						<span>标签</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/categories" class="waves-effect waves-light">
						
						<i class="fa fa-bookmark"></i>
						
						<span>分类</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/archives" class="waves-effect waves-light">
						
						<i class="fa fa-archive"></i>
						
						<span>归档</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/about" class="waves-effect waves-light">
						
						<i class="fa fa-user-circle-o"></i>
						
						<span>关于</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/friends" class="waves-effect waves-light">
						
						<i class="fa fa-address-book"></i>
						
						<span>友情链接</span>
					</a>
          
        </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">yjy239的博客</div>
        <div class="logo-desc">
            
            萌新级别的Android工程师
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
<li class="m-nav-item">
			
				<a href="/" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-home"></i>
					
					首页
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/tags" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-tags"></i>
					
					标签
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/categories" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-bookmark"></i>
					
					分类
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/archives" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-archive"></i>
					
					归档
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/about" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-user-circle-o"></i>
					
					关于
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/friends" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-address-book"></i>
					
					友情链接
				</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/yjy239" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/yjy239" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Android重学系列 红黑树
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/算法/">
                                <span class="chip bg-color">算法</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/算法/" class="post-category">
                                算法
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-03-31
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        8.1k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        31 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>红黑树，是一个比较复杂的数据结构。让我们分析一下，整个AVL树的性质。AVL最明显的特点就是，每个节点左右子树的高度差不超过1。那么就会势必产生这样的性质：当插入一个新的节点的时候时间复杂度是O(LogN)还有没有办法更快的？因此红黑树诞生了。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>先介绍一下红黑树的概念：<br>这是一种特殊的二叉搜索树。这种二叉搜索树将会符合如下5条性质：</p>
<blockquote>
<p>1.每个节点都是黑色或者红色的。<br>2.根节点是黑色的<br>3.每个叶子节点或者空节点(NIL)都是黑色的<br>4.如果一个节点是红色的，那么他的孩子节点一定是黑色<br>5.从一个节点到任意一个子孙节点的所有路径下的包含相同数目的黑色节点</p>
</blockquote>
<p>这5条性质将会确定这颗红黑树的所有性质。维持红黑树的平衡就是通过第四和第五点两个性质的约束。</p>
<h3 id="红黑树的一些有趣的性质"><a href="#红黑树的一些有趣的性质" class="headerlink" title="红黑树的一些有趣的性质"></a>红黑树的一些有趣的性质</h3><blockquote>
<p>1.一棵含有n个节点的红黑树，高度至多为$2log_2{N+1}$<br>2.红黑树的时间复杂度为: O(lgn)</p>
</blockquote>
<p>由于这本身是一个二叉搜索树，所以树的高度在极端情况下最多为$O(N)$。而到了红黑树，我们通过性质4,5可以理解到如下的情况<br><img src="/images/%E6%80%A7%E8%B4%A84%E5%92%8C5.png" alt="性质4和5.png"></p>
<p>这样的性质保证了红黑树的平衡。想想看如果我们把平衡的条件放宽一点，相比AVL树层层调整，红黑树很明显调整的次数小了2倍。因为允许左右两侧最大高度差为2倍以内。所以相比AVL树插入时候的O(logN)，而红黑树的时间复杂度只有O(logN/2)</p>
<p>接下来，我会根据增删查改，扣准上面4，5个性质，来分别解析每个方法直接的区别。</p>
<h3 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a>红黑树的定义</h3><p>同样的，我们先定义一个红黑树的结构体。</p>
<p>想想我们需要什么，左右节点，每个节点的键值对，颜色。为了方便后续的操作，还需要一个父亲节点的指针。</p>
<pre><code>template &lt;class K,class V&gt;
struct RBT::RBTreeNode{
public:
    K key;
    V value;
    rb_color color;
    RBTreeNode&lt;K,V&gt;* left;
    RBTreeNode&lt;K,V&gt;* right;
    RBTreeNode&lt;K,V&gt;* parent;

    RBTreeNode( K key,
    V value,
    rb_color color,
                RBTreeNode&lt;K,V&gt;* left,
                RBTreeNode&lt;K,V&gt;* right,
                RBTreeNode&lt;K,V&gt;* parent):key(key),value(value),
    color(color),left(left),right(right),parent(parent){

    }

};
</code></pre><h3 id="红黑树的插入动作"><a href="#红黑树的插入动作" class="headerlink" title="红黑树的插入动作"></a>红黑树的插入动作</h3><p>红黑树的插入动作比较麻烦，如何看到网上说的情况居然分出了6种情况之多，分别处理红黑树的插入行为。我的老天爷啊，怎么一个插入就要分这么多种情况？第一次学习红黑树的哥们，一定会头晕脑旋。实际上没有这么可怕，插入的思想还是继续按照AVL树的左旋右旋进一步扩展下来的。</p>
<p>唯一的不同，就是为了扣紧上面五个性质。让红黑树达到自平衡。</p>
<p>让我们进一步的思考一下，插入节点有什么情况。</p>
<ul>
<li><p>1.插入黑色节点<br>当我们插入黑色节点时候，我们会发现，立即违反性质五。也就是每个节点到它任意一个子孙节点的路径上，包含的黑色节点数目都相同。那么我们想办法要补一个黑色节点，或者通过旋转等操作，让其符合性质四，五。这种方案比较麻烦，看看插入红色节点。</p>
</li>
<li><p>2.插入红色节点<br>如果插入红色节点，可以发现，此时可能违反性质四，不违反性质5.这样我们能少考虑这上面情况，处理路径上的黑色节点数目比较困难，因此，我们将每一个新的节点先变成红色，再插入，就能尽可能避免更多的变化。但是记住我们的根节点是黑色的，所以最后要染黑。</p>
</li>
</ul>
<p>当然，假如我们的父亲节点本身就是红色节点怎么办？这样就违反性质4，红色节点的孩子节点必定是黑色节点。但是相比违反性质5，我们要做的工作会少很多。</p>
<p>让我们来写写，插入节点全部染成红色的情况。</p>
<pre><code>template &lt;class K,class V&gt;
RBTreeNode&lt;K,V&gt;* RBT::insert(K key,V value) {
    if(!root){
        root = new RBTreeNode&lt;K,V&gt;(NULL,NULL,black,NULL,NULL,NULL);
        return root;
    }


    RBTreeNode&lt;K,V&gt; *rb_node = root;
    RBTreeNode&lt;K,V&gt; *parent = NULL;


    //不允许去修改，学习binder
    do{
        parent = rb_node;
        if(key == rb_node-&gt;key){
            return rb_node;
        } else if(key &gt; rb_node-&gt;key){
            rb_node = rb_node-&gt;right;
        } else{
            rb_node = rb_node-&gt;left;
        }
    }while (rb_node);

    //知道找到对应的父亲节点，添加进去
    RBTreeNode&lt;K,V&gt; *new_node = new RBTreeNode&lt;K,V&gt;(key,value,red,NULL,NULL,parent);

    //父亲节点
    if(parent-&gt;key &gt; key){
        parent-&gt;left = new_node;
    } else{
        parent-&gt;right = new_node;
    }


    //父亲节点也添加好之后，解决双红问题

   solveDoubleRed(new_node);

    count++;

    return new_node;
}</code></pre><p>思路很简单，和AVL树一模一样，首先先找出应该在哪个父亲节点下面添加节点，并且添加下去。最后记得，由于我们这里多了parent节点的属性，我们需要根据key的大小，添加到对应的左树还是右树。</p>
<p>最后一旦发现父亲节点是红色，我们必须处理一下，双红现象。这个处理双红就是整个插入之后使得红黑树平衡的。</p>
<p>我们深入思考一下插入节点是红色的，在平衡的过程中会遇到什么阻碍。<br>最好的结果把这个多余的红色节点平衡到以另一端，这样这一侧红色就能避免双红。</p>
<h4 id="那么我们遇到第一种情况："><a href="#那么我们遇到第一种情况：" class="headerlink" title="那么我们遇到第一种情况："></a>那么我们遇到第一种情况：</h4><p><img src="/images/%E6%83%85%E5%86%B5%E4%B8%80.png" alt="情况一.png"></p>
<blockquote>
<p>此时父亲节点为黑色，直接加进去，最后染黑该节点，没有任何问题，没有违反任何性质。</p>
</blockquote>
<h4 id="第二种情况："><a href="#第二种情况：" class="headerlink" title="第二种情况："></a>第二种情况：</h4><p><img src="/images/%E6%83%85%E5%86%B5%E4%BA%8C.png" alt="情况二.png"></p>
<p>遇到这种情况，怎么办？为了保证性质5.我们试试把本节点以外的节点的一些节点染黑看看，最后为了性质3，再把叶子节点变黑，能不能达到平衡。</p>
<p>最直接的做法，试试把父亲染黑，保证性质4.<br><img src="/images/%E6%83%85%E5%86%B5%E4%BA%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%98%E5%8C%96.png" alt="情况二第一次变化.png"></p>
<p>不好这样又破坏了性质5，亡羊补牢一下，我们把爷爷节点染成红色!<br><img src="/images/%E6%83%85%E5%86%B5%E4%BA%8C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%8F%98%E5%8C%96.png" alt="情况二第二次变化.png"></p>
<p>好像整个演变都对了。那么我们可以探索出变化时候的其中一个在旋转要点，变化颜色请成对的变化。这样能保证我们在旋转的时候维持红黑点的数量保持为原来的数目。</p>
<p>其实想想也很简单，只是变化一个节点的话，那么势必会打破原来已经平衡的红黑树。那么我们这一次，为了扣紧5个性质，一口气变化红黑树上的父亲和爷爷节点，让变化过程尽可能的维持平衡。</p>
<p>插入的第二情况的解决办法：</p>
<blockquote>
<p>如果叔叔是黑色的，且新插入的节点同于生长方向，父亲染黑，爷爷染红，接着左右旋旋转</p>
</blockquote>
<h4 id="情况三："><a href="#情况三：" class="headerlink" title="情况三："></a>情况三：</h4><p><img src="/images/%E6%83%85%E5%86%B5%E4%B8%89.png" alt="情况三.png"></p>
<p>这样这种情况就分出一个分支了，当插入的节点是右孩子的时候，一次右旋是不可能维持到达上图的最后一个状态。所以只要我们在出这些步骤之前，对着福清节点左旋达到上图的状态一即可。</p>
<p>这样就是叔叔为黑色，并且加在左树的状态。同理当我们把节点加到右边，步骤不变，只是旋转的方向和加在左树的变化相反即可。</p>
<blockquote>
<p>如果叔叔是黑色的，且不同于生长方向，父亲先左右旋转，染黑此时的父亲，爷爷染红，接着左右旋旋转</p>
</blockquote>
<p>这样就是5种情况了。</p>
<p>上面的情况有个共同点，那就是叔叔是黑色的，并且父亲是红色。当叔叔节点变成红色呢？这个又怎么分析的。</p>
<h4 id="情况六"><a href="#情况六" class="headerlink" title="情况六"></a>情况六</h4><p><img src="/images/%E6%83%85%E5%86%B5%E5%85%AD.png" alt="情况六.png"><br>没想到当叔叔是红色的时候，我们把父亲染黑，把爷爷染红，叔叔染黑，就过右旋就能完成了平衡了。</p>
<p>但是事情是这么简单吗？别忘了，我们这个时候是在对三个节点变化了颜色，并没有成对的变色。虽然在这个树的高度只有2的情况下，刚好能够符合情况，但是高度再高一层，红黑树会因为染色不对称导致，整个树的平衡被破坏。</p>
<p>因此为了保证整个红黑树的自平衡，我们选择把指针移动到爷爷节点，让爷爷节点作为新的处理对象，看看上面的分支是否会出现自平衡被破坏。</p>
<blockquote>
<p>如果叔叔是红色的，把父亲染黑，爷爷染红，叔叔也要染黑，达到上面能够旋转到位的情况，由于染色不均衡，我们把指针指向爷爷，让爷爷去上层平衡。</p>
</blockquote>
<p>这样6种情况全部分析完。</p>
<p>为了操作足够方便，先提供寻找兄弟节点，父亲节点，以及染色的方法</p>
<pre><code>template &lt;class K,class V&gt;
rb_color RBT::getColor(RBTreeNode&lt;K,V&gt; *node){
    return node?node-&gt;color : black;
}

template &lt;class K,class V&gt;
RBTreeNode&lt;K,V&gt;* RBT::setColor(RBTreeNode&lt;K,V&gt; *node,rb_color color){
    if(node){
        node-&gt;color = color;
    }
}

template &lt;class K,class V&gt;
RBTreeNode&lt;K,V&gt;* RBT::left(RBTreeNode&lt;K,V&gt; *node){
    return node ? node-&gt;left : NULL;
}


template &lt;class K,class V&gt;
RBTreeNode&lt;K,V&gt;* RBT::right(RBTreeNode&lt;K,V&gt; *node){
    return node ? node-&gt;right : NULL;
}


template &lt;class K,class V&gt;
RBTreeNode&lt;K,V&gt;* RBT::parent(RBTreeNode&lt;K,V&gt; *node){
    return node ? node-&gt;parent : NULL;
}

template &lt;class K,class V&gt;
RBTreeNode&lt;K,V&gt;* RBT::brother(RBTreeNode&lt;K,V&gt; *node){
    if(!node||!node-&gt;parent) {
        return NULL;
    }
    return left(parent(node)) == node ? right(parent(node))  : left(parent(node)) ;
}</code></pre><p>完成之后，让我根据上面分析尝试着实现代码。</p>
<pre><code>void solveDoubleRed(TreeNode *pNode){
        //情况1：父亲是黑色节点不需要调整直接跳出循环
        while(pNode-&gt;parent &amp;&amp; pNode-&gt;parent-&gt;color == red){
            //情况2:叔叔是红色，则把叔叔和父亲染成黑色，爷爷染成红色指针回溯到爷爷，交给爷爷去处理
            if(getColor(brother(parent(pNode))) == red){
                setColor(parent(pNode),black);
                setColor(brother(parent(pNode)),black);
                setColor(parent(parent(pNode)),red);
                pNode = parent(parent(pNode));
            } else{
                //情况3：叔叔是黑色
                //如果叔叔是黑色的，我们把父亲染成黑色，把爷爷染成红色，
                if(left(parent(parent(pNode))) == parent(pNode)){
                    //3.1.此时当前节点是左子树的父亲右节点，与原来生长方向不一致
                    if(right(parent(pNode)) == pNode){
                        //先把父亲左旋一次，保证原来的方向
                        pNode = parent(pNode);
                        L_Rotation(pNode);
                    }

                    //3.2把这个子树的红色节点，挪动到叔叔的那颗树上.也就是父亲和舅舅变黑，爷爷变成红色
                    //再右旋转
                    //右旋一次爷爷
                    setColor(parent(pNode),black);
                    setColor(parent(parent(pNode)),red);
                    R_Rotation(parent(parent(pNode)));
                } else{
                    //3.1.此时当前节点是右子树的父亲左节点，与原来生长方向不一致
                    if(left(parent(pNode)) == pNode){
                        //先把父亲右旋一次，保证原来的方向
                        pNode = parent(pNode);
                        R_Rotation(pNode);
                    }

                    //3.2把这个子树的红色节点，挪动到叔叔的那颗树上.也就是父亲和舅舅变黑，爷爷变成红色
                    //再左旋转爷爷
                    setColor(parent(pNode),black);
                    setColor(parent(parent(pNode)),red);
                    L_Rotation(parent(parent(pNode)));
                }
            }
        }
        root-&gt;color = black;
    }</code></pre><p>弄懂了，就很简单吧。这里面有着左旋和右旋操作，这里面的实现和AVL树极其相似，实际上就是因为RBTreeNode中多了parent属性，所以我们要对parent属性进行链接。</p>
<p> 思路还是沿着AVL树。这就是为什么我要先分析AVL树。</p>
<pre><code>template &lt;class K,class V&gt;
RBTreeNode&lt;K,V&gt; *RBT::R_Roation(RBTreeNode&lt;K,V&gt; *node){
    //右旋，把左边的节点作为父亲
    RBTreeNode&lt;K,V&gt; *result_node = node-&gt;left;
    //原来右边的节点到左边去
    node-&gt;left = result_node-&gt;right;
    result_node-&gt;right = node;

    return result_node;

}</code></pre><p>但是这样就万事大吉了吗？实际上，我们在这里面对几个点做了变动，result_node,node_left,node.这些点的parent还是指向原来的地方呢？还没有做更替。</p>
<p>因此右旋完整的代码应该如下：</p>
<pre><code>template &lt;class K,class V&gt;
RBTreeNode&lt;K,V&gt; *RBT::R_Roation(RBTreeNode&lt;K,V&gt; *node){
    //右旋，把左边的节点作为父亲
    RBTreeNode&lt;K,V&gt; *result_node = node-&gt;left;
    //左边
    node-&gt;left = result_node-&gt;right;
    result_node-&gt;right = node;

    //记住最后要处理这几个节点的parent
    //此时parent 可能为空，此时为根
    //记住处理一下node本身的parent
    if(!node-&gt;parent){
        root = result_node;
    } else if(node-&gt;parent-&gt;left = node){
        node-&gt;parent-&gt;left = result_node;
    } else{
        node-&gt;parent-&gt;right = result_node;
    }
    result_node-&gt;parent = node-&gt;parent;
    if(node-&gt;left){
        node-&gt;left-&gt;parent = result_node;
    }
    node-&gt;parent = result_node;
    return result_node;
}</code></pre><p>node,result_node,node_left的父亲全部都做了处理，同理左旋则是下面的代码</p>
<pre><code>template &lt;class K,class V&gt;
RBTreeNode&lt;K,V&gt; *RBT::L_Roation(RBTreeNode&lt;K,V&gt; *node){
    //右旋，把左边的节点作为父亲
    RBTreeNode&lt;K,V&gt; *result_node = node-&gt;right;
    //左边
    node-&gt;right = result_node-&gt;left;
    result_node-&gt;left = node;

    //记住最后要处理这几个节点的parent
    //此时parent 可能为空，此时为根
    //记住处理一下node本身的parent
    if(!node-&gt;parent){
        root = result_node;
    } else if(node-&gt;parent-&gt;left = node){
        node-&gt;parent-&gt;left = result_node;
    } else{
        node-&gt;parent-&gt;right = result_node;
    }

    result_node-&gt;parent = node-&gt;parent;

    if(node-&gt;right){
        node-&gt;right-&gt;parent = result_node;
    }

    node-&gt;parent = result_node;

    return result_node;
}</code></pre><p>这样就完成了插入的动作。</p>
<p>让我们试试测试代码吧。</p>
<pre><code>    RBT&lt;int,int&gt; *map = new RBT&lt;int,int&gt;();
    map-&gt;insert(3,3);
    map-&gt;insert(2,2);
    map-&gt;insert(1,1);
    map-&gt;insert(4,4);
    map-&gt;insert(5,5);

    map-&gt;insert(-5,-5);
    map-&gt;insert(-15,-15);
    map-&gt;insert(-10,-10);
    map-&gt;insert(6,6);
    map-&gt;insert(7,7);

//
//    map-&gt;remove(2);
//    map-&gt;remove(-5);

    //map-&gt;insert(3,11);

    map-&gt;levelTravel(visit_rb);</code></pre><p>测试结果：<br><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="红黑树测试结果.png"></p>
<p>我们分解一下步骤，看看这个过程是否正确。</p>
<p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E6%AD%A5%E9%AA%A41.png" alt="红黑树添加节点步骤1.png"></p>
<p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B7%BB%E5%8A%A0%E7%BB%93%E7%82%B9%E5%88%86%E8%A7%A3%E6%AD%A5%E9%AA%A42.png" alt="红黑树添加结点分解步骤2.png"></p>
<p>根据先序遍历，输出的打印应该为2(黑)，-5( 红)，4(红),-15(黑),1(黑),3(黑),6(黑),5(红),7(红)</p>
<p>结果正确。</p>
<p>红黑树的插入检验完毕。让我们来讨论讨论红黑树的删除。</p>
<h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><p>红黑树的删除比起红黑树插入还要复杂。实际上，只要我们小心的分析每个步骤，也能盲敲出来。</p>
<p>我们继续延续AVL树的思想与步骤。<br>我们删除节点还是围绕三种基本情况来讨论。</p>
<ul>
<li>1.当删除的节点没有任何孩子<br>我们直接删除该节点</li>
<li>2.当删除的节点只有一个孩子<br>我们会拿他的左右其中一个节点来代替当前节点</li>
<li>3.当删除的节点两侧都有孩子<br>我们会删除该节点，并且找到他的后继来代替。</li>
</ul>
<p>换句话说，我会延续之前的思路，找到后续节点代替到当前要删除的节点，最后再删掉这个重复的后继节点</p>
<p>到这里都和二叉搜索树极其相似。但是不要忽略了我们5个性质。当我们删除的时候，为了保持红黑树自平衡，可以预测到的是有如下两条规则：</p>
<ul>
<li>1.删除红色节点，不破坏性质5，不影响平衡。</li>
<li>2.删除黑色节点必定破坏性质5，导致当前红黑树的被破坏</li>
</ul>
<p>我们结合着5条规则看看，究竟该怎么删除。看看删除需要遵守什么规则才能保持红黑树的自平衡。</p>
<p>我们依照着插入思路倒推一下。我们想要保持红黑树的这一侧被删除的节点的平衡，大致思路是什么？</p>
<p>首先，我们删除的节点的时候。如果直接按照搜索二叉树的思路直接删除，但是执行删除之前，我们一定会遇到删除的节点是黑色节点或红色节点情况。</p>
<p>根据上面的两条规则，假如移除一个红色节点不会破坏性质4，性质5.没有问题，我们可以直接删除。但是一旦遇到黑色节点一定破坏性质5.那么我们怎么办呢？</p>
<p>我们能够想到的一个简单的办法：就是从兄弟那边拿一个红色节点过来，再染黑这个节点，给到删除的那一侧。就能以最小的代价保持红黑树的平衡了。</p>
<p>很好，这个思路就是最为关键的核心的。那么我们实际推敲一下，在这个过程中我们会遇到什么情况吧。</p>
<h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p><img src="/images/%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E4%B8%80.png" alt="删除情况一.png"></p>
<p>直接删除红色节点不影响平衡。</p>
<p>接下来我们来考虑移除黑色节点时候该怎么处理。</p>
<h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p><img src="/images/%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E4%BA%8C.png" alt="删除情况二.png"></p>
<p>此时我们要移除2，势必造成红黑树平衡被破坏。虽然，我们一眼能看出结果这个树该怎么平衡，但是我们分解步骤看看其中有什么规律。</p>
<p>我们学习红黑树插入原理尝试着成对的处理红黑节点，把父亲节点染红和兄弟节点染黑再左旋看看结果。</p>
<p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E4%BA%8C%E5%8F%98%E5%8C%96%E4%B8%80.png" alt="红黑树删除情况二变化一.png"></p>
<p>依照这个这样下去似乎就平衡了？我们探索除了，假如兄弟节点是黑色，就把远侄子染黑就好了吗？别忘了我们的染色是为了让去除的一侧凭空多出一个黑色节点，来保证红黑树的平衡。此时我们的红黑树恰好只有一层，我们只需要稍微旋转一下就能达到平衡。所以此时是一种特殊情况。</p>
<p>这种情况应该是特殊情况。我们再看看其他的情况<br><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E4%BA%8C%E5%8F%98%E5%8C%96%E4%BA%8C.png" alt="红黑树删除情况二变化二.png"></p>
<p> 在这个时候我们尝试学习上面的办法，先把g染黑进行左旋，会发现根本不平衡。我们看看下面的变化。</p>
<p>但是思路已经开启了，我们就要多出一个红色点，转到删除的那一侧。最后再把这个红色点变成黑色。</p>
<p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E4%BA%8C%E5%8F%98%E5%8C%96%E4%B8%89.png" alt="红黑树删除情况二变化三.png"></p>
<p>也就是说，我们试着把5染成红色，2染成黑色，8染成黑色，左旋即可。这样我们可以总结出一个旋转平衡的操作：</p>
<blockquote>
<p>当兄弟节点是黑色，且远侄子是红色的时候。我们把兄弟染成父亲的颜色，再把父亲染黑，远侄子染黑，进行左/右旋转父亲即可达到平衡。</p>
</blockquote>
<p>实际上，这么做的目的很简单，让父亲变成黑的，补偿被删除的那一端，这样就能补充那一侧的节点，同时远侄子从红色染黑了，保证补偿的一侧多出一个黑色节点。而把兄弟染成父亲的颜色是为了保持这段子树的平衡。</p>
<p>这个情况二十分重要。删除的情况十分复杂，但是我们如果能把这些情况全部转化为当前这个情况。我们就能保证红黑树每一处都到了平衡。</p>
<h4 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h4><p>此时当我们的兄弟节点是黑色，且远侄子为红色的时候是这样操作。那假如兄弟节点是黑色，近侄子是红色，远侄子是黑色。怎么办？</p>
<p>下面的情况是某一个红黑树的一部分<br><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E4%B8%89(%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86).png" alt="红黑树删除情况三(红黑树的一部分).png"></p>
<p>在这个时候，我们想办法变成上面的，先试试把远侄子染成红色，为了保持这边的平衡，也要把父亲染红</p>
<p>和情况二相似，但是近侄子和远侄子的颜色相反过来。我们顺着插入操作顺着推下去，我们应该要转变成情况二那种状况，再去平衡整个红黑树。</p>
<p>关键是我们该怎么在不影响树的平衡的情况下，转化为情况二</p>
<p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E4%B8%89%E5%8F%98%E5%8C%96%E4%B8%80.png" alt="红黑树删除情况三变化一.png"></p>
<p>但是这么做有个问题，万一g此时的孩子节点是一个红色节点，就变得我们不得不去解决双红现象。这样反而更加麻烦。变量太多了，反而不好维持平衡。</p>
<p>所以上面的变化是不推荐尝试的。</p>
<p>我们试试这样的方式。我们染黑近侄子，染红兄弟，进行左旋。一样能够办到上面的情况</p>
<p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E4%B8%89%E5%8F%98%E5%8C%96%E4%BA%8C.png" alt="红黑树删除情况三变化二.png"></p>
<p>此时就是我们想要的情况，我们要删除下方的c节点，此时兄弟是黑色，远侄子是红色，同时近侄子是黑色。这样我们就进入到了情况二。</p>
<p>我们再把兄弟染成父亲的颜色，父亲再染黑，远侄子再染黑，右旋整个树<br><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E4%B8%89%E5%8F%98%E5%8C%96%E5%88%B0%E6%83%85%E5%86%B5%E4%BA%8C.png" alt="红黑树删除情况三变化到情况二.png"></p>
<p>我们数数看黑色节点数目，虽然这是红黑树的一部分节点。但是我们可以通过这种手段来维持这部分树的，黑色节点数目的不变。</p>
<p>这样我们又探索出了一个新的平衡条件</p>
<blockquote>
<p>如果兄弟节点是黑色，远侄子是黑色，近侄子是红色的，我们把兄弟染红，近侄子染黑，再左右兄弟旋转，就能达到情况二。能通过情况二把红黑树平衡下来</p>
</blockquote>
<h4 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h4><p>当我们的兄弟节点是黑色，远侄子是红色的，近侄子是黑色的（我们期望的能够一步达到的平衡条件，因为多出一个红色节点，能够通过染黑远侄子，旋转补偿删除的一侧）。以及兄弟节点是黑色，远侄子是黑色的，近侄子是红色的。</p>
<p>那么我们来考虑一下，当兄弟节点是黑色，下面两个侄子都是黑色的时候怎么办？我们没有默认的红色节点啊，没办法给删除的那一侧补偿啊。</p>
<p>下面是红黑树的一部分：<br><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E5%9B%9B(%E4%B8%A4%E4%B8%AA%E4%BE%84%E5%AD%90%E9%83%BD%E6%98%AF%E9%BB%91%E8%89%B2).png" alt="红黑树删除情况四(两个侄子都是黑色).png"></p>
<p>我们删除a的话。此时怎么办？都是黑色。没办法补偿右侧啊。我们只能学习插入的情况六。先染一个红色的节点出来，把希望寄托与上层。</p>
<p>但是我们选择怎么染颜色呢？还记得我们的情况二这种一步达到的平衡的状况，既然没有，我们就创造一个出来。</p>
<p>我们本来就要把指针移动到a(父亲)出，从上层寻找机会。那么此时的b就是相对与上层的远侄子了。那么我们把此时c的兄弟节点，b染红即可。这样我们就创造了一个远侄子是红色的情况。</p>
<p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E5%9B%9B.png" alt="红黑树删除情况四.png"></p>
<p>这样我们又解决了一个新的情况。</p>
<blockquote>
<p>如果兄弟是黑色的，且两个侄子（兄弟两个孩子）也是黑色的，则把兄弟染成红色，把指针指向父亲。此时就可以变化为接近情况二的状态，指针指向父亲，让父亲从上层找机会跳针。</p>
</blockquote>
<h4 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h4><p>我们一直在探讨兄弟是黑色的，假如兄弟是红色又怎么办。</p>
<p>下面是红黑树的某一部分：<br><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E4%BA%94.png" alt="红黑树删除情况五.png"></p>
<p>感觉此时的情况很好解决。因为此时兄弟本来就是红色的，也就是说本来就又一个红色节点提供给我们。如果能够搬到把这个节点补偿到另一侧就完成。</p>
<p>但实际上我们思考一下就明白了，为什么我们上面要以远侄子为红色而不是兄弟而红色呢？实际上很简单，我们红兄弟染黑，通过左旋和右旋，此时兄弟会成为这个子树的根，会导致两侧都增加黑色节点，这样还是不符合我们的逻辑。因此此时我们只能尝试着把这种情况往情况二，三，四变化。</p>
<p>因此我们尝试着把兄弟染黑，父亲染红<br><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E4%BA%94%E5%88%86%E8%A7%A31.png" alt="红黑树删除情况五分解1.png"></p>
<p>我们再对父亲c进行右转：<br><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B5%E4%BA%94%E5%88%86%E8%A7%A32.png" alt="红黑树删除情况五分解2.png"></p>
<p>这样我们不断的经历着遇到兄弟是红色的时候，不断染黑兄弟，父亲染红，在旋转，一定能遇到兄弟是黑色的情况。这样就回到我们的情况二三四了。</p>
<p>这样我们探索出最后一种情况。</p>
<blockquote>
<p>当兄弟是红色的时候，染黑兄弟，染红父亲，左右旋父亲。</p>
</blockquote>
<p>一直在删除右侧，实际上我们还有左侧情况考虑。</p>
<p>也就是说，删除一共有9种情况考虑。这样我们就把所有的请考虑下来了，接下来让我试试盲敲一遍。</p>
<p>在这之前，我要提供几个函数，方便我后续工作：</p>
<p>寻找后继</p>
<pre><code>    RBTreeNode* succeed(){
        //找后继，找右边的最小
        RBTreeNode *node = right;

        if(!node){
            while (node-&gt;left){
                node = node-&gt;left;
            }
            return node;
        } else{
            //当右侧没有的时候
            node = this;
            //当右侧没有的时候，不断向上找，找到此时是父亲的左孩子就是后继
            while (node-&gt;parent &amp;&amp; node-&gt;parent-&gt;right == node){
                node = node-&gt;parent;
            }

            return node-&gt;parent;
        }
    }


RBTreeNode* findTree(K key){
        RBTreeNode *node = root;
        while (node){
            if(key &lt; node-&gt;key){
                node = node-&gt;left;
            } else if(key &gt; node-&gt;key){
                node = node-&gt;right;
            } else {
                return node;
            }
        }
    }</code></pre><p>接下来我们来看看正式的删除实现：</p>
<pre><code>bool remove(K key){
        RBTreeNode *current = findTree(key);
        if(!current){
            return false;
        }

        //找到节点之后，判断当前节点的孩子节点是两个还是一个还是没有
        if(current-&gt;left &amp;&amp; current-&gt;right){
            //如果有两个节点,则取后继来代替当前
            RBTreeNode *succeed = current-&gt;succeed();

            //此时已经替换过来了，并且做替换

            //此时我们要把原来节点的数据更改过来，但是节点结构不变
            current-&gt;key = succeed-&gt;key;
            current-&gt;value = succeed-&gt;value;

            //此时，我们要调整的对象应该是后继
            current= succeed;

        }


        RBTreeNode* replace = current-&gt;left? current-&gt;left : current-&gt;right;
        //此时我们判断是左还是右把左子树还是右子树放上来
        //延续之前的思想
        if(replace){

            //断开原来所有的数据，把子孩子代替上来
            //思路是把当前parent的节点，连上replace
            if(!current-&gt;parent){
                //说明当前已经是根部
                root = replace;
            } else if(current-&gt;parent-&gt;left == current){
                //说明此时左边节点，我们要把数据代替到父亲的左节点
                current-&gt;parent-&gt;left = replace;
            } else{
                current-&gt;parent-&gt;right = replace;
            }

            //替换掉节点
            replace-&gt;parent = current-&gt;parent;

            if(current-&gt;color == black){
                //处理代替的节点
                solveLostblack(replace);
            }
            delete(current);
        } else if(current-&gt;parent == NULL){
            //此时已经是根部了
            delete(root);
            root = NULL;
        } else{

            if(current-&gt;color == black){
                solveLostblack(current);
            }

            //把current的parent的孩子信息都清空
            if(current-&gt;parent-&gt;left == current){
                current-&gt;parent-&gt;left = NULL;
            } else {
                current-&gt;parent-&gt;right = NULL;
            }

            //此时是叶子节点
            delete(current);
        }





        count--;
        return true;

    }</code></pre><p>关键是怎么解决删除黑色节点问题。</p>
<pre><code>void solveLostblack(RBTreeNode *node){
        //此时进入情况一
        //当节点删除的节点是红色则不用管
        while(node != root&amp;&amp; node-&gt;color == black){
            //此时判断当前是左树还是右树
            if(node-&gt;parent-&gt;left == node){
                //此时进入情况五，兄弟节点是红色
                RBTreeNode *sib = brother(node);
                if(getColor(brother(node)) == red){
                    //兄弟染黑，父亲染红，删除了左树，补偿左树，左旋父亲
                    setColor(brother(node),black);
                    setColor(parent(node),red);
                    L_Roation(parent(node));
                    sib = brother(node);
                }

                //此时进入情况3/4
                //情况四
                //兄弟是黑，两个侄子也是黑
                if(getColor(sib)==black
                   &amp;&amp; getColor(left(sib)) == black
                   &amp;&amp; getColor(right(sib)) == black){
                    //兄弟染红，指针移动到父亲,创造一个红色远侄子
                    setColor(sib,red);
                    node = parent(node);
                } else {


                    //如果兄弟是黑，远侄子是黑
                    //此时近侄子是左，远侄子是右
                    if( getColor(right(sib)) == black){
                        //还是想办法创造一个红色的远侄子
                        //兄弟变红
                        setColor(sib,red);
                        //近侄子变黑
                        setColor(left(sib),black);
                        //此时远侄子在右边，我们需要右旋
                         R_Roation(sib);
                        sib = brother(node);
                    }


                    //此时兄弟是黑，远侄子是红色
                    //把兄弟染成父亲的颜色，父亲染黑，远侄子染黑，左旋

                    setColor(sib,getColor(parent(node)));
                    setColor(parent(node),black);
                    setColor(right(sib),black);
                    L_Roation(parent(node));

                    //此时已经没有必要在调整了，已经成功了
                    node = root;

                }


            } else{
                RBTreeNode *sib = brother(node);
                //此时进入情况五，兄弟节点是红色
                if(getColor(sib) == red){
                    //兄弟染黑，父亲染红，删除了左树，补偿右树，右旋父亲
                    setColor(sib,black);
                    setColor(parent(node),red);
                    R_Roation(parent(node));
                    sib = brother(node);
                }

                //此时进入情况3/4
                //情况四
                //兄弟是黑，两个侄子也是黑
                if(getColor(sib)==black
                   &amp;&amp; getColor(left(sib)) == black
                   &amp;&amp; getColor(right(sib)) == black){
                    //兄弟染红，指针移动到父亲,创造一个红色远侄子
                    setColor(sib,red);
                    node = parent(node);
                } else {

                    //如果兄弟是黑，远侄子是黑
                    //此时近侄子是右，远侄子是左
                    if( getColor(left(sib)) == black){
                        //还是想办法创造一个红色的远侄子
                        //兄弟变红
                        setColor(sib,red);
                        //近侄子变黑
                        setColor(right(sib),black);
                        //此时远侄子在右边，我们需要右旋
                        L_Roation(sib);
                        sib = brother(node);
                    }


                    //此时兄弟是黑，远侄子是红色
                    //把兄弟染成父亲的颜色，父亲染黑，远侄子染黑，左旋
                    setColor(sib,getColor(parent(node)));
                    setColor(parent(node),black);
                    setColor(left(sib),black);
                    R_Roation(parent(node));

                    //此时已经没有必要在调整了，已经成功了
                    node = root;

                }


            }

        }

        node-&gt;color = black;

    }</code></pre><p>按照思路已经完成整个思想，我来测试看看究竟对不对</p>
<pre><code>    RBT&lt;int,int&gt; *map = new RBT&lt;int,int&gt;();
    map-&gt;insert(3,3);
    map-&gt;insert(2,2);
    map-&gt;insert(1,1);
    map-&gt;insert(4,4);
    map-&gt;insert(5,5);

    map-&gt;insert(-5,-5);
    map-&gt;insert(-15,-15);
    map-&gt;insert(-10,-10);
    map-&gt;insert(6,6);
    map-&gt;insert(7,7);

//
    map-&gt;remove(2);
    map-&gt;remove(-5);


    map-&gt;levelTravel(visit_rb);</code></pre><p><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%8C%E6%88%90%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="红黑树完成测试结果.png"></p>
<p>我们来试试分解步骤进行解析<br><img src="/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E5%88%86%E8%A7%A3%E6%AD%A5%E9%AA%A4%E4%BE%8B%E5%AD%90.png" alt="红黑树删除分解步骤例子.png"></p>
<p>根据前序便利，结果是3，-10,6,-15,1,4,7,5</p>
<p>结果正确。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>红黑树是我们初级程序员能够接触到几乎最复杂的数据结构。我也花了好长时间的学习，推导，盲敲以及修改bug。</p>
<p>根据我的盲敲的心得，红黑树的插入，删除有这么一个小诀窍。<br>插入看叔叔，删除看兄弟。插入避免双红，删除处理丢黑。<br>记住插入根本，当叔为黑，父染黑，爷染红，根据情况左右旋<br>记住删除根本，当兄为黑，远侄子为红，就把兄弟染成父亲色，父亲远侄子染黑，根据情况左右旋。<br>遇到生长不如意，反向旋转父或兄，回到根本去平衡。<br>倘若遇到，插入叔为红，父染黑，爷染红；<br>删除侄子都为黑，兄染红，回溯上层找机会。<br>删除遇到兄弟为红，染黑兄，染红父，根据情况左右旋。</p>
<p>实际上插入和删除的操作，从根本就是抓住5个性质，所以实际上还是有很大的相似性。只要记住一点，插入避免双红，我们就要看叔叔那边的情况，能不能处理双红，毕竟也要即使处理完这一侧的双红，也要避免另一侧的双红。</p>
<p>删除处理丢黑，能不能处理丢黑，就要看看兄弟是否是黑以及远侄子是否是红。远侄子是否为红代表着是否能通过不改变这一侧的黑色节点数，为删除的一侧添加黑色节点，而兄弟节点是否是黑色决定着其侄子究竟有没有红。如果兄弟为红色，我们必须进行旋转，来达到我们兄弟为黑色情况，这样我们就能避免双红的出现，同时处理远侄子为红的条件。</p>
<p>说了这么多，本来想结合binder的红黑树一起来探讨，但是篇幅有限，我就不再这里赘述了。我本来以为我没办法盲敲出红黑树的，毕竟我当年第一次接触的时候，脑子乱的。但是仔细分析了6种插入情况，9种删除情况，发现自己也行的，没有想象的这么难。</p>
<p>这次红黑树的盲敲让我明白了，很多看起来困难的事情，只要自己一步一脚印的去做，或许能达到意想不到的效果呢。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>


            


        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/05/02/syscall-yuan-li-yi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="Android 重学系列 Binder驱动的初始化 syscall原理">
                        
                        <span class="card-title">Android 重学系列 Binder驱动的初始化 syscall原理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            背景聊完前面的红黑树算法，让我复习，学习Binder驱动的内容。Binder可以说是整个Android系统中最为常用的进程间通讯。无论是AMS，WMS，PMS，几乎所有的Android核心服务都通过Binder向四面八方的应用通信。可以说是
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2019-05-02
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Binder/" class="post-category">
                                    Binder
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Android/">
                        <span class="chip bg-color">Android</span>
                    </a>
                    
                    <a href="/tags/Android-Framework/">
                        <span class="chip bg-color">Android Framework</span>
                    </a>
                    
                    <a href="/tags/Linux-kernel/">
                        <span class="chip bg-color">Linux kernel</span>
                    </a>
                    
                    <a href="/tags/Binder/">
                        <span class="chip bg-color">Binder</span>
                    </a>
                    
                    <a href="/tags/系统调用/">
                        <span class="chip bg-color">系统调用</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/03/22/android-chong-xue-xi-lie-avl-shu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.jpg" class="responsive-img" alt="Android重学系列 AVL树">
                        
                        <span class="card-title">Android重学系列 AVL树</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            背景接着上面那个二叉搜索树来讲。有思考过二叉搜索树最差的搜索时间复杂度吗？最差的时候，二叉搜索树插入的数据刚好是一条直线，这样时间复杂度就蜕变和链表没什么区别（就是从O(logN)蜕变到O(n)级别）。因此AVL树因此诞生了。
如下图所示：
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-03-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/算法/" class="post-category">
                                    算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/算法/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: yjy239的博客<br />'
            + '作者: yjy239<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="center-align copy-right">
            <!-- 本站由&nbsp;&copy;<a href="https://github.com/yjy239/yjy239.github.io.git" target="_blank">yjy239</a>&nbsp;基于
            <a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>&nbsp;主题搭建 -->
            <!-- <br> -->
            <div>&copy;Copyright yjy239的博客</div>
            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">804k</span>&nbsp;字
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fa fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            <br>
            <!-- <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span> -->
            <!-- <script>
                var now = new Date();

                function createtime() {
                    var grt = new Date("11/05/2019 00:00:00");
                    now.setTime(now.getTime() + 250);
                    days = (now - grt) / 1000 / 60 / 60 / 24;
                    dnum = Math.floor(days);
                    hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
                    hnum = Math.floor(hours);
                    if (String(hnum).length == 1) {
                        hnum = "0" + hnum;
                    }
                    minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
                    mnum = Math.floor(minutes);
                    if (String(mnum).length == 1) {
                        mnum = "0" + mnum;
                    }
                    seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                    snum = Math.round(seconds);
                    if (String(snum).length == 1) {
                        snum = "0" + snum;
                    }
                    document.getElementById("timeDate").innerHTML = "本站已安全运行 " + dnum + " 天 ";
                    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
                }
                setInterval("createtime()", 250);
            </script> -->
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/yjy239" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>
















    <a href="https://www.jianshu.com/u/3a14616d66ba" class="tooltipped" target="_blank" data-tooltip="关注我的简书: https://www.jianshu.com/u/3a14616d66ba" data-position="top" data-delay="50">
        <i class="fa fa-inverse">简</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 在线聊天工具  洪卫 shw2018 modify 2019.09.17 -->
    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: ""
        });
        daovoice('update');
    </script>
    

    

    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon.min.js" async="async"></script>
    

    
    
    

</body>

</html>
