<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="kotlin 协程源码浅析, Android | Linux | Flutter">
    <meta name="description" content="前言kotlin 现在都比较新鲜的一个语言。问过了身边的朋友，有的似乎开始用其开始写后台，有的开始用kotlin重构Android工程代码。甚至有朋友说，kotlin的协程在腾讯面试Android的时候被面了。如今深深的感觉到了，kotli">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>kotlin 协程源码浅析 | yjy239的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">yjy239的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right nav-menu">
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/" class="waves-effect waves-light">
						
						<i class="fa fa-home"></i>
						
						<span>首页</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/tags" class="waves-effect waves-light">
						
						<i class="fa fa-tags"></i>
						
						<span>标签</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/categories" class="waves-effect waves-light">
						
						<i class="fa fa-bookmark"></i>
						
						<span>分类</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/archives" class="waves-effect waves-light">
						
						<i class="fa fa-archive"></i>
						
						<span>归档</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/about" class="waves-effect waves-light">
						
						<i class="fa fa-user-circle-o"></i>
						
						<span>关于</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/friends" class="waves-effect waves-light">
						
						<i class="fa fa-address-book"></i>
						
						<span>友情链接</span>
					</a>
          
        </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">yjy239的博客</div>
        <div class="logo-desc">
            
            萌新级别的Android工程师
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
<li class="m-nav-item">
			
				<a href="/" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-home"></i>
					
					首页
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/tags" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-tags"></i>
					
					标签
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/categories" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-bookmark"></i>
					
					分类
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/archives" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-archive"></i>
					
					归档
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/about" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-user-circle-o"></i>
					
					关于
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/friends" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-address-book"></i>
					
					友情链接
				</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/yjy239" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/yjy239" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        kotlin 协程源码浅析
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Android/">
                                <span class="chip bg-color">Android</span>
                            </a>
                        
                            <a href="/tags/kotlin/">
                                <span class="chip bg-color">kotlin</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/kotlin/" class="post-category">
                                kotlin
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2018-04-22
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        5.4k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        25 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>kotlin 现在都比较新鲜的一个语言。问过了身边的朋友，有的似乎开始用其开始写后台，有的开始用kotlin重构Android工程代码。甚至有朋友说，kotlin的协程在腾讯面试Android的时候被面了。如今深深的感觉到了，kotlin已经悄然声息的走进了我们的开发生活中。相信不久的将来一定有不少基于kotlin的优秀的第三方库。本人也只是刚刚学习kotlin，学习到了协程决定尝试着分析它的源码。兑现我之前写的多线程设计模式那一篇所说的，把kotlin的源码翻出来，让我们来聊聊kotlin的协程吧。但是事先声明，这个源码是基于kotlin1.1，官方都说了是实验作品，说明以后可能会大变。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>老规矩，我们先学会如何使用kotlin的协程序。</p>
<pre><code>val result = async(CommonPool) {
            work()
        }

        launch {
            log("result is ${result.await()}")
        }
</code></pre><pre><code>//这是log方法
fun log(msg:String):Unit{
        Log.e(TAG,"[${Thread.currentThread().name}] $msg")
    }

//这是work方法
   suspend fun work():String{
        delay(3000L)   //模拟一个耗时任务
        return "job"
    }</code></pre><p>这就是kotlin中，协程最基础的用法。很简单，比起我们在java中编写多线程的时候简单多了。</p>
<p>具体是什么意思呢？为了以后的阅读这边稍微说一下，async括号里面是是一个单例模式的线程池，说明的是括号里面的程序将要在这个线程里面运行。而async这个扩展函数将会启动线程，并且返回一个Deferred对象。</p>
<p>在launch中也会启动一个线程池子，在这个线程里面我们就会等待async返回出job并且打印出来。</p>
<p>究竟对不对，我们看看源码就知道了。顺道一体，这一篇文章要解决async中究竟是不是我之前说那样运用了Future模式。以及launch和async区别。</p>
<p>前提提要，这里我就不多讨论lamda表达式，并不是今天的重点。我们要了解其中的思想。</p>
<h4 id="async-参数和构建器解析"><a href="#async-参数和构建器解析" class="headerlink" title="async 参数和构建器解析"></a>async 参数和构建器解析</h4><p>老规矩上源码：</p>
<pre><code>public fun &lt;T&gt; async(
    context: CoroutineContext = DefaultDispatcher,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; T
): Deferred&lt;T&gt; {
    val newContext = newCoroutineContext(context)
    val coroutine = if (start.isLazy)
        LazyDeferredCoroutine(newContext, block) else
        DeferredCoroutine&lt;T&gt;(newContext, active = true)
    coroutine.initParentJob(context[Job])
    start(block, coroutine, coroutine)
    return coroutine
}</code></pre><p>方法里面设定了默认的几个参数context  类型是CoroutineContext，start<br> 类型是CoroutineStart，以及用过类型安全的构建器把block中的内容往下穿。</p>
<p>我们先看看这个DefaultDispatcher究竟是什么。</p>
<pre><code>public val DefaultDispatcher: CoroutineDispatcher = CommonPool</code></pre><p>我们一直这是一个CommonPool也就是说就算我们不声明CommonPool，也会默认为CommonPool。我们再看看CommonPool是啥东西</p>
<pre><code>object CommonPool : CoroutineDispatcher() {
    private var usePrivatePool = false

    @Volatile
    private var _pool: Executor? = null

    private inline fun &lt;T&gt; Try(block: () -&gt; T) = try { block() } catch (e: Throwable) { null }

    private fun createPool(): ExecutorService {
        val fjpClass = Try { Class.forName("java.util.concurrent.ForkJoinPool") }
            ?: return createPlainPool()
        if (!usePrivatePool) {
            Try { fjpClass.getMethod("commonPool")?.invoke(null) as? ExecutorService }
                ?.let { return it }
        }
        Try { fjpClass.getConstructor(Int::class.java).newInstance(defaultParallelism()) as? ExecutorService }
            ?. let { return it }
        return createPlainPool()
    }

    private fun createPlainPool(): ExecutorService {
        val threadId = AtomicInteger()
        return Executors.newFixedThreadPool(defaultParallelism()) {
            Thread(it, "CommonPool-worker-${threadId.incrementAndGet()}").apply { isDaemon = true }
        }
    }

    private fun defaultParallelism() = (Runtime.getRuntime().availableProcessors() - 1).coerceAtLeast(1)

    @Synchronized
    private fun getOrCreatePoolSync(): Executor =
        _pool ?: createPool().also { _pool = it }

    override fun dispatch(context: CoroutineContext, block: Runnable) =
        try { (_pool ?: getOrCreatePoolSync()).execute(timeSource.trackTask(block)) }
        catch (e: RejectedExecutionException) {
            timeSource.unTrackTask()
            DefaultExecutor.execute(block)
        }

    // used for tests
    @Synchronized
    internal fun usePrivatePool() {
        shutdown(0)
        usePrivatePool = true
        _pool = null
    }

    // used for tests
    @Synchronized
    internal fun shutdown(timeout: Long) {
        (_pool as? ExecutorService)?.apply {
            shutdown()
            if (timeout &gt; 0)
                awaitTermination(timeout, TimeUnit.MILLISECONDS)
            shutdownNow().forEach { DefaultExecutor.execute(it) }
        }
        _pool = Executor { throw RejectedExecutionException("CommonPool was shutdown") }
    }

    // used for tests
    @Synchronized
    internal fun restore() {
        shutdown(0)
        usePrivatePool = false
        _pool = null
    }

    override fun toString(): String = "CommonPool"
}</code></pre><p>提一下，CommonPool是一个标志了object的类，这个在kotlin的意思是编译的时候只会产生唯一一个对象，也就是我们java所说的单例模式。</p>
<p>从这里我们可以看到很关键的东西，createPool的方法返回了一个ExecutorService这个类，我们在java中多线程编程也有一个ExecutorService这个类。我们点击去看看</p>
<pre><code>package java.util.concurrent;</code></pre><p>确实是我们的java中的ExecutorService。我们接下来可以做出以下合理的推测，kotlin中的协程是不是也是调用了我们java中thread来完成的。</p>
<pre><code>    private fun createPlainPool(): ExecutorService {
        val threadId = AtomicInteger()
        return Executors.newFixedThreadPool(defaultParallelism()) {
            Thread(it, "CommonPool-worker-${threadId.incrementAndGet()}").apply { isDaemon = true }
        }
    }</code></pre><p>我们的这个创建池子调用createPlainPool的方法。也是和我们Java中使用Executors线程池一样的用法。</p>
<p>那么我们的推测是对的，可以下这么一个结论，kotlin的协程实际上就是我们的java的线程，更加准确的说是线程池。</p>
<p>我们再看看第二个参数start，类型是CoroutineStart</p>
<pre><code>public enum class CoroutineStart {
    /**
     * Default -- immediately schedules coroutine for execution according to its context.
     *
     * If the [CoroutineDispatcher] of the coroutine context returns `true` from [CoroutineDispatcher.isDispatchNeeded]
     * function as most dispatchers do, then the coroutine code is dispatched for execution later, while the code that
     * invoked the coroutine builder continues execution.
     *
     * Note, that [Unconfined] dispatcher always returns `false` from its [CoroutineDispatcher.isDispatchNeeded]
     * function, so starting coroutine with [Unconfined] dispatcher by [DEFAULT] is the same as using [UNDISPATCHED].
     *
     * If coroutine [Job] is cancelled before it even had a chance to start executing, then it will not start its
     * execution at all, but complete with an exception.
     *
     * Cancellability of coroutine at suspension points depends on the particular implementation details of
     * suspending functions. Use [suspendCancellableCoroutine] to implement cancellable suspending functions.
     */
    DEFAULT,

    /**
     * Starts coroutine lazily, only when it is needed.
     *
     * See the documentation for the corresponding coroutine builders for details:
     * [launch], [async], and [actor][kotlinx.coroutines.experimental.channels.actor].
     *
     * If coroutine [Job] is cancelled before it even had a chance to start executing, then it will not start its
     * execution at all, but complete with an exception.
     */
    LAZY,

    /**
     * Atomically (non-cancellably) schedules coroutine for execution according to its context.
     * This is similar to [DEFAULT], but the coroutine cannot be cancelled before it starts executing.
     *
     * Cancellability of coroutine at suspension points depends on the particular implementation details of
     * suspending functions as in [DEFAULT].
     */
    ATOMIC,

    /**
     * Immediately executes coroutine until its first suspension point _in the current thread_ as if it the
     * coroutine was started using [Unconfined] dispatcher. However, when coroutine is resumed from suspension
     * it is dispatched according to the [CoroutineDispatcher] in its context.
     *
     * This is similar to [ATOMIC] in the sense that coroutine starts executing even if it was already cancelled,
     * but the difference is that it start executing in the same thread.
     *
     * Cancellability of coroutine at suspension points depends on the particular implementation details of
     * suspending functions as in [DEFAULT].
     */
    UNDISPATCHED;

    /**
     * Starts the corresponding block as a coroutine with this coroutine start strategy.
     *
     * * [DEFAULT] uses [startCoroutineCancellable].
     * * [ATOMIC] uses [startCoroutine].
     * * [UNDISPATCHED] uses [startCoroutineUndispatched].
     * * [LAZY] does nothing.
     */
    public operator fun &lt;T&gt; invoke(block: suspend () -&gt; T, completion: Continuation&lt;T&gt;) =
        when (this) {
            CoroutineStart.DEFAULT -&gt; block.startCoroutineCancellable(completion)
            CoroutineStart.ATOMIC -&gt; block.startCoroutine(completion)
            CoroutineStart.UNDISPATCHED -&gt; block.startCoroutineUndispatched(completion)
            CoroutineStart.LAZY -&gt; Unit // will start lazily
        }

    /**
     * Starts the corresponding block with receiver as a coroutine with this coroutine start strategy.
     *
     * * [DEFAULT] uses [startCoroutineCancellable].
     * * [ATOMIC] uses [startCoroutine].
     * * [UNDISPATCHED] uses [startCoroutineUndispatched].
     * * [LAZY] does nothing.
     */
    public operator fun &lt;R, T&gt; invoke(block: suspend R.() -&gt; T, receiver: R, completion: Continuation&lt;T&gt;) =
        when (this) {
            CoroutineStart.DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion)
            CoroutineStart.ATOMIC -&gt; block.startCoroutine(receiver, completion)
            CoroutineStart.UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)
            CoroutineStart.LAZY -&gt; Unit // will start lazily
        }

    /**
     * Returns `true` when [LAZY].
     */
    public val isLazy: Boolean get() = this === LAZY
}</code></pre><p>我们可以得知，这个类是一个枚举类。默认是DEFAULT，也就是说，返回的isLazy一般情况是false。</p>
<h4 id="async-方法流程"><a href="#async-方法流程" class="headerlink" title="async 方法流程"></a>async 方法流程</h4><p>有了这个基础，我们继续分析构建器里面的代码。</p>
<pre><code>    val newContext = newCoroutineContext(context)
    val coroutine = if (start.isLazy)
        LazyDeferredCoroutine(newContext, block) else
        DeferredCoroutine&lt;T&gt;(newContext, active = true)
    coroutine.initParentJob(context[Job])
    start(block, coroutine, coroutine)
    return coroutine</code></pre><p>我们查阅newCoroutineContext下面的方法，实际上是为了debug做处理，我们不多讨论，只需要知道在我们默认情况下继续返回了CommonPool。</p>
<p>按照我们刚才分析coroutine 由于判断isLazy是false，这个形参实际上是DeferredCoroutine。</p>
<h5 id="initParentJob-线程初始化"><a href="#initParentJob-线程初始化" class="headerlink" title="initParentJob 线程初始化"></a>initParentJob 线程初始化</h5><p>接着我们看看initParentJob 初始化了什么东西。由于知道DeferredCoroutine这个类</p>
<pre><code>@Suppress("UNCHECKED_CAST")
private open class DeferredCoroutine&lt;T&gt;(
    parentContext: CoroutineContext,
    active: Boolean
) : AbstractCoroutine&lt;T&gt;(parentContext, active), Deferred&lt;T&gt; {
    override fun getCompleted(): T = getCompletedInternal() as T
    suspend override fun await(): T = awaitInternal() as T
    override val onAwait: SelectClause1&lt;T&gt;
        get() = this as SelectClause1&lt;T&gt;
}</code></pre><p>由于我们可以知道这个类继承了AbstractCoroutine。而这个类也是继承了JobSupport这个类，这个类实际上是扩展了Job这个接口。注意这个地方就是重点，是用来标记这个线程任务的状态。</p>
<p>我们看看initParent是怎么回事</p>
<pre><code>    public fun initParentJob(parent: Job?) {
        check(parentHandle == null)
        if (parent == null) {
            parentHandle = NonDisposableHandle
            return
        }
        parent.start() // make sure the parent is started
        val handle = parent.attachChild(this)
        parentHandle = handle
        // now check our state _after_ registering (see updateState order of actions)
        if (isCompleted) handle.dispose()
    }</code></pre><p>由于传进来的parent实际上是DeferredCoroutine，我们其实也是调用JobSupport中start，attachChild方法。我们一一看看</p>
<pre><code>    public final override fun start(): Boolean {
        loopOnState { state -&gt;
            when (startInternal(state)) {
                FALSE -&gt; return false
                TRUE -&gt; return true
            }
        }
    }</code></pre><p>在这个loopOnState是一个循环体</p>
<pre><code>    protected inline fun loopOnState(block: (Any?) -&gt; Unit): Nothing {
        while (true) {
            block(state)
        }
    }</code></pre><p>不断的调用startInternal判断状态</p>
<pre><code>    // returns: RETRY/FALSE/TRUE:
    //   FALSE when not new,
    //   TRUE  when started
    //   RETRY when need to retry
    private fun startInternal(state: Any?): Int {
        when (state) {
            is Empty -&gt; { // EMPTY_X state -- no completion handlers
                if (state.isActive) return FALSE // already active
                if (!_state.compareAndSet(state, EmptyActive)) return RETRY
                onStart()
                return TRUE
            }
            is NodeList -&gt; { // LIST -- a list of completion handlers (either new or active)
                return state.tryMakeActive().also { result -&gt;
                    if (result == TRUE) onStart()
                }
            }
            else -&gt; return FALSE // not a new state
        }
    }</code></pre><p>我们现在有两种状态，Empty 和NodeList。</p>
<pre><code>@Suppress("PrivatePropertyName")
private val EmptyNew = Empty(false)
@Suppress("PrivatePropertyName")
private val EmptyActive = Empty(true)
...
private val _state = atomic&lt;Any?&gt;(if (active) EmptyActive else EmptyNew)

private class Empty(override val isActive: Boolean) : JobSupport.Incomplete {
    override val list: JobSupport.NodeList? get() = null
    override fun toString(): String = "Empty{${if (isActive) "Active" else "New" }}"
}</code></pre><p>这就是证据。我们一般的情况active是false，那么协程的第一个初始是EmptyNew状态。接下来发现是EmptyNew的状态通过CAS转化为EmptyActive状态。</p>
<p>我们继续看看，attachChild绑定方法</p>
<pre><code>override fun attachChild(child: Job): DisposableHandle =
        invokeOnCompletion(onCancelling = true, handler = Child(this, child))</code></pre><pre><code>    public final override fun invokeOnCompletion(onCancelling: Boolean, handler: CompletionHandler): DisposableHandle =
        installHandler(handler, onCancelling = onCancelling &amp;&amp; hasCancellingState)</code></pre><p>我们再看看installhandler的方法</p>
<pre><code>private fun installHandler(handler: CompletionHandler, onCancelling: Boolean): DisposableHandle {
        var nodeCache: JobNode&lt;*&gt;? = null
        loopOnState { state -&gt;
            when (state) {
                is Empty -&gt; { // EMPTY_X state -- no completion handlers
                    if (state.isActive) {
                        // try move to SINGLE state
                        val node = nodeCache ?: makeNode(handler, onCancelling).also { nodeCache = it }
                        if (_state.compareAndSet(state, node)) return node
                    } else
                        promoteEmptyToNodeList(state) // that way we can add listener for non-active coroutine
                }
                is Incomplete -&gt; {
                    val list = state.list
                    if (list == null) { // SINGLE/SINGLE+
                        promoteSingleToNodeList(state as JobNode&lt;*&gt;)
                    } else {
                        if (state is Finishing &amp;&amp; state.cancelled != null &amp;&amp; onCancelling) {
                            // installing cancellation handler on job that is being cancelled
                            handler((state as? CompletedExceptionally)?.exception)
                            return NonDisposableHandle
                        }
                        val node = nodeCache ?: makeNode(handler, onCancelling).also { nodeCache = it }
                        if (addLastAtomic(state, list, node)) return node
                    }
                }
                else -&gt; { // is complete
                    handler((state as? CompletedExceptionally)?.exception)
                    return NonDisposableHandle
                }
            }
        }
    }</code></pre><p>这个方法就是处理整个Job状态的关键函数在这里面处理了一下协程几种状态，一个是Empty，InComplete，complete状态。我们当前是Empty状态，非活跃状态。所以将会调用promoteEmptyToNodeList方法</p>
<pre><code>    private fun promoteEmptyToNodeList(state: Empty) {
        // try to promote it to list in new state
        _state.compareAndSet(state, NodeList(state.isActive))
    }</code></pre><p>又看到了这个方法，是不是很熟悉。就是我上一篇聊过的CAS乐观锁。这个方法是在Empty状态尝试把线程中活跃状态颠倒一下，也就是说，我们现在就是处于通过CAS尝试着把Empty状态的协程状态从非活跃状态转换为活跃状态。同时把state转换为NodeList。</p>
<p>接下来就会在Looper这个循环体走到handler的分支</p>
<pre><code>val node = nodeCache ?: makeNode(handler, onCancelling).also { nodeCache = it }
                        if (_state.compareAndSet(state, node)) return node</code></pre><p>通过可以知道我们将会创建一个新的任务节点并且通过CAS修改state中的node，让里面的node不为空</p>
<pre><code>    private fun makeNode(handler: CompletionHandler, onCancelling: Boolean): JobNode&lt;*&gt; =
        if (onCancelling)
            (handler as? JobCancellationNode&lt;*&gt;)?.also { require(it.job === this) }
                ?: InvokeOnCancellation(this, handler)
        else
            (handler as? JobNode&lt;*&gt;)?.also { require(it.job === this &amp;&amp; (!hasCancellingState || it !is JobCancellationNode)) }
                ?: InvokeOnCompletion(this, handler)</code></pre><p>看到这个不要觉得奇怪，also是返回了当前对象，把它当作我们常见的链式调用就好了，最后会返回了InvokeOnCompletion。这个对象是一个JobNode。</p>
<pre><code>internal abstract class JobNode&lt;out J : Job&gt;(
    @JvmField val job: J
) : LockFreeLinkedListNode(), DisposableHandle, CompletionHandler, JobSupport.Incomplete {
    final override val isActive: Boolean get() = true
    final override val list: JobSupport.NodeList? get() = null
    final override fun dispose() = (job as JobSupport).removeNode(this)
    override abstract fun invoke(reason: Throwable?)
}</code></pre><p>这里我们可以发现它刚好扩展了DisposableHandle这个取消任务的接口。所以我们在最后发现</p>
<pre><code>if (isCompleted) handle.dispose()</code></pre><p>这一旦判断这个任务已经完成了，则会移除掉当前的节点。这里稍微提一下LockFreeLinkedListNode这个类。它实际上是一个线程安全的链表，主要是通过CAS完成线程安全的。</p>
<h4 id="async-启动线程"><a href="#async-启动线程" class="headerlink" title="async 启动线程"></a>async 启动线程</h4><p>接着就走start这个枚举类的构造函数。我们抽出看一下：</p>
<pre><code>    public operator fun &lt;T&gt; invoke(block: suspend () -&gt; T, completion: Continuation&lt;T&gt;) =
        when (this) {
            CoroutineStart.DEFAULT -&gt; block.startCoroutineCancellable(completion)
            CoroutineStart.ATOMIC -&gt; block.startCoroutine(completion)
            CoroutineStart.UNDISPATCHED -&gt; block.startCoroutineUndispatched(completion)
            CoroutineStart.LAZY -&gt; Unit // will start lazily
        }</code></pre><p>这段代码实际上kotlin的特性，这个operator的方法标志，是告诉你，我要重写某种操作符了。而invoke一般是指构造函数。</p>
<p>那么就是说接下来start的方法接下来会走invoke的CoroutineStart.DEFAULT分支。为了提一下可能有0基础的，这个when我们可以看成switch类似的东西。</p>
<p>我们再进去看看。</p>
<pre><code>internal fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;) =
    createCoroutineUnchecked(completion).resumeCancellable(Unit)</code></pre><p>这里开始的方法名字开始像我们java中的futuretask了。我们详细看看里面是怎么回事。</p>
<p>我们先看看createCoroutineUnchecked这个方法究竟创建了一个什么对象，由于我们显示的设置了接受者是CommonPool，那么走进将会这个函数</p>
<pre><code>@SinceKotlin("1.1")
@kotlin.jvm.JvmVersion
public fun &lt;R, T&gt; (suspend R.() -&gt; T).createCoroutineUnchecked(
        receiver: R,
        completion: Continuation&lt;T&gt;
): Continuation&lt;Unit&gt; =
        if (this !is kotlin.coroutines.experimental.jvm.internal.CoroutineImpl)
            buildContinuationByInvokeCall(completion) {
                @Suppress("UNCHECKED_CAST")
                (this as Function2&lt;R, Continuation&lt;T&gt;, Any?&gt;).invoke(receiver, completion)
            }
        else
            (this.create(receiver, completion) as kotlin.coroutines.experimental.jvm.internal.CoroutineImpl).facade</code></pre><p>走到这里我们开始很疑惑了，这个this按照道理来说是block的对象，然而我查遍整个apk编译出来的类都没有实现这个CoroutineImpl这个抽象类的类。着实让我费解了很久。接着我反编译我的apk之后，发现这个是kotlin的一个特性，它会根据写的代码会适当的在MainActivity扩展一些内部类。jdk-gui上看不到的，我的AS点击decompiler也没有效果，最后还是这个工具<br><a href="https://github.com/skylot/jadx">https://github.com/skylot/jadx</a><br>解了我的燃眉之急。</p>
<pre><code>final class MainActivity$onCreate$result$1 extends CoroutineImpl implements Function2&lt;CoroutineScope, Continuation&lt;? super String&gt;, Object&gt; {
    private CoroutineScope p$;
    final /* synthetic */ MainActivity this$0;

    MainActivity$onCreate$result$1(MainActivity mainActivity, Continuation continuation) {
        this.this$0 = mainActivity;
        super(2, continuation);
    }

    @NotNull
    public final Continuation&lt;Unit&gt; create(@NotNull CoroutineScope $receiver, @NotNull Continuation&lt;? super String&gt; $continuation) {
        Intrinsics.checkParameterIsNotNull($receiver, "$receiver");
        Intrinsics.checkParameterIsNotNull($continuation, "$continuation");
        Continuation mainActivity$onCreate$result$1 = new MainActivity$onCreate$result$1(this.this$0, $continuation);
        mainActivity$onCreate$result$1.p$ = $receiver;
        return mainActivity$onCreate$result$1;
    }

    @Nullable
    public final Object invoke(@NotNull CoroutineScope $receiver, @NotNull Continuation&lt;? super String&gt; $continuation) {
        Intrinsics.checkParameterIsNotNull($receiver, "$receiver");
        Intrinsics.checkParameterIsNotNull($continuation, "$continuation");
        return ((MainActivity$onCreate$result$1) create($receiver, (Continuation) $continuation)).doResume(Unit.INSTANCE, null);
    }

    @Nullable
    public final Object doResume(@Nullable Object obj, @Nullable Throwable th) {
        Object coroutine_suspended = IntrinsicsKt.getCOROUTINE_SUSPENDED();
        switch (this.label) {
            case 0:
                if (th != null) {
                    throw th;
                }
                CoroutineScope coroutineScope = this.p$;
                MainActivity mainActivity = this.this$0;
                this.label = 1;
                obj = mainActivity.work(this);
                return obj == coroutine_suspended ? coroutine_suspended : obj;
            case 1:
                if (th == null) {
                    return obj;
                }
                throw th;
            default:
                throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
        }
    }
}</code></pre><p>我们可以看见这个地方kotlin编译器编译出了新的内部类。上面那个create的方法实际上就是走的这个create方法，返回了一个实现了CoroutineImpl的MainActivity$onCreate$result$1的对象。</p>
<p>接着我们继续接着上面调用了facade对象</p>
<pre><code>private val _context: CoroutineContext? = completion?.context

val facade: Continuation&lt;Any?&gt; get() {
        if (_facade == null) _facade = interceptContinuationIfNeeded(_context!!, this)
        return _facade!!
    }
</code></pre><p>接着调用下面的</p>
<pre><code>internal fun &lt;T&gt; interceptContinuationIfNeeded(
        context: CoroutineContext,
        continuation: Continuation&lt;T&gt;
) = context[ContinuationInterceptor]?.interceptContinuation(continuation) ?: continuation</code></pre><p>那么这些参数对应了哪几个呢？<br>1.completion 对应了DeferredCoroutine<br>2.那么context对应了newCoroutineContext。而我们前面就说了newCoroutineContext实际上是指的是CommonPool。</p>
<p>还记得CommonPool继承了CoroutineDispatcher这个抽象类，而这个类实际上就是扩展了</p>
<pre><code>public abstract class CoroutineDispatcher :
        AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor</code></pre><p>换句话说，我们实际上调用的是CoroutineDispatcher的interceptContinuation，这个方法将会返回一个DispatchedContinuation对象</p>
<pre><code>public override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; =
            DispatchedContinuation(this, continuation)</code></pre><p>DispatchedContinuation而这个类就是重点开始分发</p>
<pre><code>internal class DispatchedContinuation&lt;in T&gt;(
    @JvmField val dispatcher: CoroutineDispatcher,
    @JvmField val continuation: Continuation&lt;T&gt;
): Continuation&lt;T&gt; by continuation {
    override fun resume(value: T) {
        val context = continuation.context
        if (dispatcher.isDispatchNeeded(context))
            dispatcher.dispatch(context, DispatchTask(continuation, value, exception = false, cancellable = false))
        else
            resumeUndispatched(value)
    }

    override fun resumeWithException(exception: Throwable) {
        val context = continuation.context
        if (dispatcher.isDispatchNeeded(context))
            dispatcher.dispatch(context, DispatchTask(continuation, exception, exception = true, cancellable = false))
        else
            resumeUndispatchedWithException(exception)
    }

    @Suppress("NOTHING_TO_INLINE") // we need it inline to save us an entry on the stack
    inline fun resumeCancellable(value: T) {
        val context = continuation.context
        if (dispatcher.isDispatchNeeded(context))
            dispatcher.dispatch(context, DispatchTask(continuation, value, exception = false, cancellable = true))
        else
            resumeUndispatched(value)
    }

    @Suppress("NOTHING_TO_INLINE") // we need it inline to save us an entry on the stack
    inline fun resumeCancellableWithException(exception: Throwable) {
        val context = continuation.context
        if (dispatcher.isDispatchNeeded(context))
            dispatcher.dispatch(context, DispatchTask(continuation, exception, exception = true, cancellable = true))
        else
            resumeUndispatchedWithException(exception)
    }

    @Suppress("NOTHING_TO_INLINE") // we need it inline to save us an entry on the stack
    inline fun resumeUndispatched(value: T) {
        withCoroutineContext(context) {
            continuation.resume(value)
        }
    }

    @Suppress("NOTHING_TO_INLINE") // we need it inline to save us an entry on the stack
    inline fun resumeUndispatchedWithException(exception: Throwable) {
        withCoroutineContext(context) {
            continuation.resumeWithException(exception)
        }
    }

    // used by "yield" implementation
    internal fun dispatchYield(value: T) {
        val context = continuation.context
        dispatcher.dispatch(context, DispatchTask(continuation, value,false, true))
    }

    override fun toString(): String =
        "DispatchedContinuation[$dispatcher, ${continuation.toDebugString()}]"
}</code></pre><p>看到这里，如果看过okhttp源码的朋友一定会惊呼，这不就是okhttp的拦截器模式吗？这里面同理，CoroutineDispatcher扩展了一个协同拦截器的接口，一个类似链表一样的接口。也就是在最上面context[job]的时候，把这个新的任务丢进到链表里面，最后再通过DispatchedContinuation分发任务。</p>
<p>是不是这样我们再看看，我们几乎走完了createCoroutineUnchecked这个函数接下来我们看看它调用的resumeCancellable。</p>
<pre><code>internal fun &lt;T&gt; Continuation&lt;T&gt;.resumeCancellable(value: T) = when (this) {
    is DispatchedContinuation -&gt; resumeCancellable(value)
    else -&gt; resume(value)
}</code></pre><p>和我们分析的一致会判断一次DispatchedContinuation的类型，接着走resumeCancellable方法。</p>
<pre><code>    inline fun resumeCancellable(value: T) {
        val context = continuation.context
        if (dispatcher.isDispatchNeeded(context))
            dispatcher.dispatch(context, DispatchTask(continuation, value, exception = false, cancellable = true))
        else
            resumeUndispatched(value)
    }</code></pre><p>这个方法实际上是DispatchedContinuation内部的分发动作。</p>
<pre><code>    override fun dispatch(context: CoroutineContext, block: Runnable) =
        try { (_pool ?: getOrCreatePoolSync()).execute(timeSource.trackTask(block)) }
        catch (e: RejectedExecutionException) {
            timeSource.unTrackTask()
            DefaultExecutor.execute(block)
        }</code></pre><p>接着最后走到CommonPool里面的dispatch方法。看到没有，这里就走到了execute这个线程执行器启动线程并且把block，也就是安全构建器这个async大括号内的内容统统放到了线程中执行。如果出现了拒绝的一场就添加到队列里面。</p>
<p>这就是协程启动线程的流程。</p>
<p>这就完了吗，还有几点要注意的：</p>
<pre><code>internal class DispatchTask&lt;in T&gt;(
    private val continuation: Continuation&lt;T&gt;,
    private val value: Any?, // T | Throwable
    private val exception: Boolean,
    private val cancellable: Boolean
) : Runnable {
    @Suppress("UNCHECKED_CAST")
    override fun run() {
        try {
            val context = continuation.context
            val job = if (cancellable) context[Job] else null
            withCoroutineContext(context) {
                when {
                    job != null &amp;&amp; !job.isActive -&gt; continuation.resumeWithException(job.getCancellationException())
                    exception -&gt; continuation.resumeWithException(value as Throwable)
                    else -&gt; continuation.resume(value as T)
                }
            }
        } catch (e: Throwable) {
            throw RuntimeException("Unexpected exception running $this", e)
        }
    }

    override fun toString(): String =
        "DispatchTask[${continuation.toDebugString()}, cancellable=$cancellable, value=${value.toSafeString()}]"
}</code></pre><p>这个dispatchTask实际上扩展了java中的runnable方法。这里面重写了run的方法。这里就是为了切换Job。</p>
<p>我们看看，这里有几种状态我们逐一分析一下，顺便总结一下，<br>Job是线程初始化的时候绑定<br>如果是job != null &amp;&amp; !job.isActive这个状态说明是一个异常状态以及抛出了异常。</p>
<p>正常情况下会走resume的方法。<br>如果分发器发现还有下一个任务就会继续封装一个runnable对象启动线程。不然就执行下面resumeUndispatched。</p>
<pre><code>    final override fun resume(value: T) {
        makeCompleting(value, defaultResumeMode)
    }</code></pre><pre><code>internal fun makeCompleting(proposedUpdate: Any?, mode: Int): Boolean {
        loopOnState { state -&gt;
            if (state !is Incomplete)
                throw IllegalStateException("Job $this is already complete, but is being completed with $proposedUpdate", proposedUpdate.exceptionOrNull)
            if (state is Finishing &amp;&amp; state.completing)
                throw IllegalStateException("Job $this is already completing, but is being completed with $proposedUpdate", proposedUpdate.exceptionOrNull)
            val child: Child = firstChild(state) ?: // or else complete immediately w/o children
                if (updateState(state, proposedUpdate, mode)) return true else return@loopOnState
            // must promote to list to correct operate on child lists
            if (state is JobNode&lt;*&gt;) {
                promoteSingleToNodeList(state)
                return@loopOnState // retry
            }
            // cancel all children in list on exceptional completion
            if (proposedUpdate is CompletedExceptionally)
                child.cancelChildrenInternal(proposedUpdate.exception)
            // switch to completing state
            val completing = Finishing(state.list!!, (state as? Finishing)?.cancelled, true)
            if (_state.compareAndSet(state, completing)) {
                waitForChild(child, proposedUpdate)
                return false
            }
        }
    }</code></pre><p>这个方法就是切换Job状态的，如果state是JobNode的类型则获取下一个新的的节点，再返回。一旦后面的任务队列已经没有任何东西了，就会走到了completing，尝试着修改为completing的状态，最后再去调用下一个aysnc的方法。</p>
<p>只有这点东西吗？不对这一次我们是来看看async是怎么做到future。别忘了，DeferredCoroutine这个类还扩展了第二个接口，Deferred。</p>
<p>我们看看await的方法：</p>
<pre><code>    protected suspend fun awaitInternal(): Any? {
        // fast-path -- check state (avoid extra object creation)
        while(true) { // lock-free loop on state
            val state = this.state
            if (state !is Incomplete) {
                // already complete -- just return result
                if (state is CompletedExceptionally) throw state.exception
                return state

            }
            if (startInternal(state) &gt;= 0) break // break unless needs to retry
        }
        return awaitSuspend() // slow-path
    }</code></pre><p>这个方法，实际上就是不断的检测state这个状态是否是完成状态，是的话，就把结果返回去。</p>
<p>也就印证了我之前说的，我们的future模式。在kotlin中我们先拿到了一个DeferredCoroutine作为一个句柄，我们调用await的时候实际上是在自己想要获取的地方等待线程完成获取自己想要的数据。</p>
<p>那么launch呢？</p>
<pre><code>public fun launch(
    context: CoroutineContext = DefaultDispatcher,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; Unit
): Job {
    val newContext = newCoroutineContext(context)
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)
    coroutine.initParentJob(context[Job])
    start(block, coroutine, coroutine)
    return coroutine
}</code></pre><p>很明显，这里面只是扩展了Job这个控制线程的接口，并没有获取方法的函数。</p>
<p>可以很轻易的发现Deferred和Java中的Callable很相似，但是更加的灵活了。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>kotlin作为一门新的语言，我学习的时间不长，但是不断看源码的路上，从源码上学习到了不少kotlin的一些用法。虽然可能将的可能会漏。我感觉这确实是一种成长。估计之后的1-2个月暂时不会去写文章了，公司给了一个挺有意思的课题，接下来我会全力去做。这篇文章我本来也是写了一半，了却之前没有完成的事情。</p>
<p>如果有疑问请在本文找我：<a href="https://www.jianshu.com/p/56b7650642c0" target="_blank" rel="noopener">https://www.jianshu.com/p/56b7650642c0</a></p>
<p>对了未来的一段日子里面我会陆陆续续添加类的时序图和类的结构图。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>


            


        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2018/06/24/python-duo-xian-cheng-de-chu-bu-tan-suo-cong-queue-tan-suo/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="python多线程的初步探索(从Queue探索)">
                        
                        <span class="card-title">python多线程的初步探索(从Queue探索)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            前言自学了快4天的python。有些东西还是需要自己记录一下，故此写下该随笔。
在学习python的时候，编写多线程的时候，顺手写一个经典的消费者和生产者模式时候。发现一个有趣的东西。在Java中我往往需要wait或者调用lock的方法去等
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2018-06-24
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/python/" class="post-category">
                                    python
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/python/">
                        <span class="chip bg-color">python</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2018/04/05/cong-yuan-ma-jiao-du-kan-asynctask-yu-loadermanager-duo-xian-cheng-she-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="从源码角度看AsyncTask与LoaderManager多线程设计">
                        
                        <span class="card-title">从源码角度看AsyncTask与LoaderManager多线程设计</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            题外话哈，搁置了一段时间没有写博客。主要是去研究Android虚拟机和ffmpeg中ffplay的源码了。计划上是时候把AsyncTask和其中蕴含的多线程编程思想和大家所得分享一下，自己也需要记录一下。之后可能将计划把handler最后一
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2018-04-05
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Android-Framework/" class="post-category">
                                    Android Framework
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Android/">
                        <span class="chip bg-color">Android</span>
                    </a>
                    
                    <a href="/tags/Android-Framework/">
                        <span class="chip bg-color">Android Framework</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: yjy239的博客<br />'
            + '作者: yjy239<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="center-align copy-right">
            <!-- 本站由&nbsp;&copy;<a href="https://github.com/yjy239/yjy239.github.io.git" target="_blank">yjy239</a>&nbsp;基于
            <a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>&nbsp;主题搭建 -->
            <!-- <br> -->
            <div>&copy;Copyright yjy239的博客</div>
            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">804k</span>&nbsp;字
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fa fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            <br>
            <!-- <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span> -->
            <!-- <script>
                var now = new Date();

                function createtime() {
                    var grt = new Date("11/05/2019 00:00:00");
                    now.setTime(now.getTime() + 250);
                    days = (now - grt) / 1000 / 60 / 60 / 24;
                    dnum = Math.floor(days);
                    hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
                    hnum = Math.floor(hours);
                    if (String(hnum).length == 1) {
                        hnum = "0" + hnum;
                    }
                    minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
                    mnum = Math.floor(minutes);
                    if (String(mnum).length == 1) {
                        mnum = "0" + mnum;
                    }
                    seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                    snum = Math.round(seconds);
                    if (String(snum).length == 1) {
                        snum = "0" + snum;
                    }
                    document.getElementById("timeDate").innerHTML = "本站已安全运行 " + dnum + " 天 ";
                    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
                }
                setInterval("createtime()", 250);
            </script> -->
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/yjy239" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>
















    <a href="https://www.jianshu.com/u/3a14616d66ba" class="tooltipped" target="_blank" data-tooltip="关注我的简书: https://www.jianshu.com/u/3a14616d66ba" data-position="top" data-delay="50">
        <i class="fa fa-inverse">简</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 在线聊天工具  洪卫 shw2018 modify 2019.09.17 -->
    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: ""
        });
        daovoice('update');
    </script>
    

    

    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon.min.js" async="async"></script>
    

    
    
    

</body>

</html>
