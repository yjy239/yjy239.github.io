<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="从源码角度横向分析Glide和Picasso, Android | Linux | Flutter">
    <meta name="description" content="Glide和Picasso这两个库，是现在Android里面是开发中比较常用的两个库。而且用法极其的相似，很多人也喜欢拿这两者比较。这一次我自己亲自看了一遍源码，对两者进行了比较。
本人才疏学浅，有错误的地方请指出，在原地址在下面:http">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>从源码角度横向分析Glide和Picasso | yjy239的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">yjy239的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right nav-menu">
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/" class="waves-effect waves-light">
						
						<i class="fa fa-home"></i>
						
						<span>首页</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/tags" class="waves-effect waves-light">
						
						<i class="fa fa-tags"></i>
						
						<span>标签</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/categories" class="waves-effect waves-light">
						
						<i class="fa fa-bookmark"></i>
						
						<span>分类</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/archives" class="waves-effect waves-light">
						
						<i class="fa fa-archive"></i>
						
						<span>归档</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/about" class="waves-effect waves-light">
						
						<i class="fa fa-user-circle-o"></i>
						
						<span>关于</span>
					</a>
          
        </li>
    
    <li class="hide-on-med-and-down nav-item" >
		
					  <a href="/friends" class="waves-effect waves-light">
						
						<i class="fa fa-address-book"></i>
						
						<span>友情链接</span>
					</a>
          
        </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">yjy239的博客</div>
        <div class="logo-desc">
            
            萌新级别的Android工程师
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
<li class="m-nav-item">
			
				<a href="/" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-home"></i>
					
					首页
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/tags" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-tags"></i>
					
					标签
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/categories" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-bookmark"></i>
					
					分类
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/archives" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-archive"></i>
					
					归档
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/about" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-user-circle-o"></i>
					
					关于
				</a>
          
        </li>
        
<li class="m-nav-item">
			
				<a href="/friends" class="waves-effect waves-light">
					
					<i class="fa fa-fw fa-address-book"></i>
					
					友情链接
				</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/yjy239" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/yjy239" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        从源码角度横向分析Glide和Picasso
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Android/">
                                <span class="chip bg-color">Android</span>
                            </a>
                        
                            <a href="/tags/Android-常用第三方库/">
                                <span class="chip bg-color">Android 常用第三方库</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Android-常用第三方库/" class="post-category">
                                Android 常用第三方库
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2018-01-30
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        10.8k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        51 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>Glide和Picasso这两个库，是现在Android里面是开发中比较常用的两个库。而且用法极其的相似，很多人也喜欢拿这两者比较。这一次我自己亲自看了一遍源码，对两者进行了比较。</p>
<p>本人才疏学浅，有错误的地方请指出，在原地址在下面:<br><a href="https://www.jianshu.com/p/4de87ebf5104" target="_blank" rel="noopener">https://www.jianshu.com/p/4de87ebf5104</a></p>
<h1 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h1><p>先看看Glide的用法：</p>
<pre><code>Glide.with(this).load("url").into(imageview);</code></pre><p>先从Glide 3.7.0开始说明。就从网络加载图片为例子：<br>先看看整个时序图：<img src="/images/Glide%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="Glide时序图.jpg"></p>
<p>由于调用链十分长，而且大量的使用接口编程。这么看或许还不够直观，在这里，我附上一个glide中每个角色负责的功能图。</p>
<p><img src="/images/Glide%E4%B8%BB%E8%A6%81%E8%A7%92%E8%89%B2.png" alt="Glide主要角色.png"></p>
<p>这里包含了在上述流程中所用到的主要功能模块。</p>
<h3 id="Glide各个职能"><a href="#Glide各个职能" class="headerlink" title="Glide各个职能"></a>Glide各个职能</h3><p>1.Engine 是整个Glide的引擎，无论是加载图片还是链接网络都是通过这个Engine的类进行启动,而且通过里面的MainHandler进行异步刷新图片。无论是glide-v3还是glide-v4，这一块的功能都没怎么变动过。发生变化的是，glide-v4感觉上学习了Picasso多了几种图片加载的状态，每一次完成一部分就切换当前资源的状态。</p>
<p>2.ResourceTranscoder 这个是Glide进行类型变换的类，换句话就是转化器。比如说当我们准备加载url的时候，我们获取到的是Resource<bitmap> 的resource类型，但是我们获取之后需要对bitmap进行一些处理，我们需要进行对这个Resource进行转化，因此会在回调之前，会把无绘制加工的Resource类型转化为有绘制加工的GlideBitmapDrawableResource。注意，这个和我们常用用来转化圆角的transform()产生的transformtion不是一个东西。</bitmap></p>
<p>3.DataLoadProvider Glide核心部分，因为这一部分是Glide用于解析bitmap，链接网络，读取本地文件等等，所用到的数据读取时候提供的decode，encode类。</p>
<p>4.ModelLoader是Glide另一处核心部分，这个是用于生成用于读取的数据，比如说String转化为InputStream等。而且妙的一点那是，每个生成工厂之间可以嵌套，最后会一层层解析获取到一些参数，进入到最为基础的数据模型。</p>
<p>4.bitmapPool顾名思义，就是指bitmap池子</p>
<p>5.Cache 是特指DiskCache和MemoryCache两种，前者是指磁盘上的缓存，后者是指内存上的缓存。</p>
<p>6.Target 这个是指每一次加载的目标资源，每个target都包含一次请求动作Request。</p>
<p>7.Request 这个是指每一次事件的请求。</p>
<p>8.还有其他的，在这里不多做讨论。毕竟glide做的事情很多，篇幅有限先不说了。</p>
<p>上述这些模块会在Glide调用with的时候，调用单例，进行初始化，并且在构造函数中进行初始化。其中我们要尤其注意一点，除了ModelLoader，ResourceTranscoder，DataLoadProvider是通过register方法到下面两个类，其他都是在构造器里面就是可以初始化好。而在glide-v4中，这些所有的东西都会注册到Registry里面，在通过getloadpath获取对应ModelLoader，获取到之后进行解析，而且没有这么多Request，通过RequestBuilder创建一个SingleRequest。这一点的重构使得glide-v4比起glide-v3轻量了很多。由于大家用的v3还是多一点，这里挑出v3和大家说一下。</p>
<p>###Glide的注册表</p>
<pre><code>    private final GenericLoaderFactory loaderFactory;
    private final TranscoderRegistry transcoderRegistry 
    private final DataLoadProviderRegistry 
Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, Context context, DecodeFormat decodeFormat) {
...
//容器注册方法
    dataLoadProviderRegistry.register(InputStream.class, Bitmap.class, streamBitmapLoadProvider);

//ModelLoader注册调用
    register(String.class, InputStream.class, new StreamStringLoader.Factory());

....

//转换器注册方法
transcoderRegistry.register(GifBitmapWrapper.class, GlideDrawable.class,
                new GifBitmapWrapperDrawableTranscoder(
                        new GlideBitmapDrawableTranscoder(context.getResources(), bitmapPool)));

..

}


//ModelLoader在Glide类里面的方法
public &lt;T, Y&gt; void register(Class&lt;T&gt; modelClass, Class&lt;Y&gt; resourceClass, ModelLoaderFactory&lt;T, Y&gt; factory) {
        ModelLoaderFactory&lt;T, Y&gt; removed = loaderFactory.register(modelClass, resourceClass, factory);
        if (removed != null) {
            removed.teardown();
        }
    }


//根据你注册对应的两个类的参数，获取对应的ModelLoader
    public static &lt;T, Y&gt; ModelLoader&lt;T, Y&gt; buildModelLoader(Class&lt;T&gt; modelClass, Class&lt;Y&gt; resourceClass,
            Context context) {
         if (modelClass == null) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Unable to load null model, setting placeholder only");
            }
            return null;
        }
        return Glide.get(context).getLoaderFactory().buildModelLoader(modelClass, resourceClass);
    }
</code></pre><p>最后一个方法尤为的重要，但是我学习源码的时候，就是没有注意到这里根本找不到解析接口对应的实现类是哪个。</p>
<p>好了，铺垫都差不多了，虽然Darren大佬和郭霖大佬都写过了，再写一遍着实有点没意思，我这一次从他们没怎么说过的角度来解析，一起比较Picasso源码，好了闲话到这里，我们开始Glide的源码旅程。</p>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>先从with的方法开始</p>
<pre><code>    public static RequestManager with(FragmentActivity activity) {
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        return retriever.get(activity);
    }</code></pre><p>从我上面那个流程图，可以知道最后会调用fragmentGet</p>
<pre><code>    RequestManager fragmentGet(Context context, android.app.FragmentManager fm) {
        RequestManagerFragment current = getRequestManagerFragment(fm);
        RequestManager requestManager = current.getRequestManager();
        if (requestManager == null) {
            requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
            current.setRequestManager(requestManager);
        }
        return requestManager;
    }

    RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) {
        RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
        if (current == null) {
            current = pendingRequestManagerFragments.get(fm);
            if (current == null) {
                current = new RequestManagerFragment();
                pendingRequestManagerFragments.put(fm, current);
                fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
                handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
            }
        }
        return current;
    }</code></pre><p>这个方法在我们的activity上面创建一个隐藏的fragment，这fragment的作用可以和外面的activity,fragment的生命周期同步。这么做的好处，我们可以把加载图片等行为和生命周期同步，不需要把onresume,onstop等方法暴露在使用者眼里，很好是遵守了设计模式中的单一原则。</p>
<h3 id="Glide-load"><a href="#Glide-load" class="headerlink" title="Glide load"></a>Glide load</h3><p>而返回的RequestManager，会帮助我们创建好，一个事件请求类GenericRequest，这个类就是整个事件请求的起点。<br>由于我们研究的是网络请求的流程</p>
<pre><code>    public DrawableTypeRequest&lt;String&gt; load(String string) {
        return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);
    }</code></pre><p>根据我的时序图可以清楚到了loadGeneric：</p>
<pre><code>private &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) {
        ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);
        ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader =
                Glide.buildFileDescriptorModelLoader(modelClass, context);
        if (modelClass != null &amp;&amp; streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) {
            throw new IllegalArgumentException("Unknown type " + modelClass + ". You must provide a Model of a type for"
                    + " which there is a registered ModelLoader, if you are using a custom model, you must first call"
                    + " Glide#register with a ModelLoaderFactory for your custom model class");
        }

        return optionsApplier.apply(
                new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,
                        glide, requestTracker, lifecycle, optionsApplier));
    }</code></pre><h3 id="Glide-into"><a href="#Glide-into" class="headerlink" title="Glide into"></a>Glide into</h3><p>而里面这个DrawableTypeRequest父类就是GenericRequestBuilder，这样就可以通过这个建造者创建一个请求，我们在看into方法，所有的核心逻辑都在这里。</p>
<pre><code>
    public Target&lt;TranscodeType&gt; into(ImageView view) {
        Util.assertMainThread();
        if (view == null) {
            throw new IllegalArgumentException("You must pass in a non null View");
        }

        if (!isTransformationSet &amp;&amp; view.getScaleType() != null) {
            switch (view.getScaleType()) {
                case CENTER_CROP:
                    applyCenterCrop();
                    break;
                case FIT_CENTER:
                case FIT_START:
                case FIT_END:
                    applyFitCenter();
                    break;
                //$CASES-OMITTED$
                default:
                    // Do nothing.
            }
        }
        return into(glide.buildImageViewTarget(view, transcodeClass));
    }</code></pre><p>注意在这里我们要通过网络下载一个bitmap，我们从buildImageViewTarget知道我们会生成BitmapImageViewTarget。记住它，最后我们会回调他的onResourceReady</p>
<pre><code>    public &lt;Z&gt; Target&lt;Z&gt; buildTarget(ImageView view, Class&lt;Z&gt; clazz) {
        if (GlideDrawable.class.isAssignableFrom(clazz)) {
            return (Target&lt;Z&gt;) new GlideDrawableImageViewTarget(view);
        } else if (Bitmap.class.equals(clazz)) {
            return (Target&lt;Z&gt;) new BitmapImageViewTarget(view);
        } else if (Drawable.class.isAssignableFrom(clazz)) {
            return (Target&lt;Z&gt;) new DrawableImageViewTarget(view);
        } else {
            throw new IllegalArgumentException("Unhandled class: " + clazz
                    + ", try .as*(Class).transcode(ResourceTranscoder)");
        }
    }</code></pre><p>在下面这个函数我们创建一个GenericRequest的请求类，在lifecycle监听这个请求事件，这将会同步整个生命周期，而requestTracker.runRequest(request);将会启动Engine的load的方法，并且声明了DecodeJob和EngineRunnable。</p>
<pre><code>    public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) {
        Util.assertMainThread();
        if (target == null) {
            throw new IllegalArgumentException("You must pass in a non null Target");
        }
        if (!isModelSet) {
            throw new IllegalArgumentException("You must first set a model (try #load())");
        }

        Request previous = target.getRequest();

        if (previous != null) {
            previous.clear();
            requestTracker.removeRequest(previous);
            previous.recycle();
        }

        Request request = buildRequest(target);
        target.setRequest(request);
        lifecycle.addListener(target);
        requestTracker.runRequest(request);
        return target;
    }</code></pre><p>这里我们需要看看GenericRequest,有2点值得注意学习一下</p>
<pre><code>    @Override
    public void begin() {
        startTime = LogTime.getLogTime();
        if (model == null) {
            onException(null);
            return;
        }

        status = Status.WAITING_FOR_SIZE;
        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
            onSizeReady(overrideWidth, overrideHeight);
        } else {
            target.getSize(this);
        }

        if (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) {
            target.onLoadStarted(getPlaceholderDrawable());
        }
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished run method in " + LogTime.getElapsedMillis(startTime));
        }
    }

    @Override
    public void onSizeReady(int width, int height) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
        }
        if (status != Status.WAITING_FOR_SIZE) {
            return;
        }
        status = Status.RUNNING;

        width = Math.round(sizeMultiplier * width);
        height = Math.round(sizeMultiplier * height);

        ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();
        final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);

        if (dataFetcher == null) {
            onException(new Exception("Failed to load model: \'" + model + "\'"));
            return;
        }
        ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
        }
        loadedFromMemoryCache = true;
        loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,
                priority, isMemoryCacheable, diskCacheStrategy, this);
        loadedFromMemoryCache = resource != null;
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
        }
    }</code></pre><p>在这个begin的方法中，我们是在 onSizeReady启动Engine，启动里面的线程池子。这个过程是一个耗时的过程，所以不需要等待将会有设置了默认图就设置默认图</p>
<pre><code> if (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) {
            target.onLoadStarted(getPlaceholderDrawable());
        }</code></pre><p>第一点：这个简单的处理切合了多线程的设计模式，Thread-per-Message设计<br>模式。多线程编程的很多时候我们需要这种思想，在耗时的工作的时候，我们可以把耗时的工作交给另一个类，而我们可以立即拿到一个返回。</p>
<p>第二点：和Picasso不同，glide会生成一个enginekey来寻找是否存在相同的请求。而每一次key里面也会算上图片对应的width，height。也就是说不同的宽高会被视为不同的请求而去再一次请求一次。</p>
<p>根据我的时序图截下来会到DecoderJob里面：</p>
<pre><code>private Resource&lt;T&gt; decodeSource() throws Exception {
        Resource&lt;T&gt; decoded = null;
        try {
            long startTime = LogTime.getLogTime();
            final A data = fetcher.loadData(priority);
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                logWithTimeAndKey("Fetched data", startTime);
            }
            if (isCancelled) {
                return null;
            }
            decoded = decodeFromSourceData(data);
        } finally {
            fetcher.cleanup();
        }
        return decoded;
    }</code></pre><h3 id="Glide-联网和decode"><a href="#Glide-联网和decode" class="headerlink" title="Glide 联网和decode"></a>Glide 联网和decode</h3><p>在这里，第一次看glide的人一定会遇到瓶颈，这个loadData点进去是一个接口，根本找不到在哪里实现这个方法。这个时候就要回到我最早说的地方，获取到注册在GenericLoaderFactory里面去找转化方法。</p>
<p>其实是在创建GenericRequest的时候创建的的一个FixedLoadProvider，所有的东西都是从里面获取的。</p>
<p>这里我们讨论的时候网络连接图片，当然是从String转化为InputStream，所以对应的fetcher是new StreamStringLoader.Factory()。</p>
<pre><code>register(String.class, InputStream.class, new StreamStringLoader.Factory());
</code></pre><p>之后你会发现这个factory里面不断的嵌套下面这个方法</p>
<pre><code> buildModelLoader(Class&lt;T&gt; modelClass, Class&lt;Y&gt; resourceClass);</code></pre><p>不断的在注册表里面找，最终会到达此处HttpUrlGlideUrlLoader,而fetcher.loadData(priority);中的fetcher就是通过</p>
<pre><code>@Override
    public DataFetcher&lt;InputStream&gt; getResourceFetcher(GlideUrl model, int width, int height) {
        // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time spent parsing urls.
        GlideUrl url = model;
        if (modelCache != null) {
            url = modelCache.get(model, 0, 0);
            if (url == null) {
                modelCache.put(model, 0, 0, model);
                url = model;
            }
        }
        return new HttpUrlFetcher(url);
    }</code></pre><p>来获取HttpUrlFetche这个转化器里面，在这里面的loadData则是联网的步骤：</p>
<pre><code>    @Override
    public InputStream loadData(Priority priority) throws Exception {
        return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders());
    }

    private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map&lt;String, String&gt; headers)
            throws IOException {
        if (redirects &gt;= MAXIMUM_REDIRECTS) {
            throw new IOException("Too many (&gt; " + MAXIMUM_REDIRECTS + ") redirects!");
        } else {
            // Comparing the URLs using .equals performs additional network I/O and is generally broken.
            // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
            try {
                if (lastUrl != null &amp;&amp; url.toURI().equals(lastUrl.toURI())) {
                    throw new IOException("In re-direct loop");
                }
            } catch (URISyntaxException e) {
                // Do nothing, this is best effort.
            }
        }
        urlConnection = connectionFactory.build(url);
        for (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) {
          urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
        }
        urlConnection.setConnectTimeout(2500);
        urlConnection.setReadTimeout(2500);
        urlConnection.setUseCaches(false);
        urlConnection.setDoInput(true);

        // Connect explicitly to avoid errors in decoders if connection fails.
        urlConnection.connect();
        if (isCancelled) {
            return null;
        }
        final int statusCode = urlConnection.getResponseCode();
        if (statusCode / 100 == 2) {
            return getStreamForSuccessfulRequest(urlConnection);
        } else if (statusCode / 100 == 3) {
            String redirectUrlString = urlConnection.getHeaderField("Location");
            if (TextUtils.isEmpty(redirectUrlString)) {
                throw new IOException("Received empty or null redirect url");
            }
            URL redirectUrl = new URL(url, redirectUrlString);
            return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
        } else {
            if (statusCode == -1) {
                throw new IOException("Unable to retrieve response code from HttpUrlConnection.");
            }
            throw new IOException("Request failed " + statusCode + ": " + urlConnection.getResponseMessage());
        }
    }


    private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)
            throws IOException {
        if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {
            int contentLength = urlConnection.getContentLength();
            stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);
        } else {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Got non empty content encoding: " + urlConnection.getContentEncoding());
            }
            stream = urlConnection.getInputStream();
        }
        return stream;
    }</code></pre><p>这样就从String转化为InputStream。</p>
<p>拿到我们读的数据流，接下来就要做解析的事情的了，根据上面的时序图，接下来会走到下面：</p>
<pre><code>    private Resource&lt;T&gt; decodeFromSourceData(A data) throws IOException {
        final Resource&lt;T&gt; decoded;
        if (diskCacheStrategy.cacheSource()) {
            decoded = cacheAndDecodeSourceData(data);
        } else {
            long startTime = LogTime.getLogTime();
            decoded = loadProvider.getSourceDecoder().decode(data, width, height);
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                logWithTimeAndKey("Decoded from source", startTime);
            }
        }
        return decoded;
    }</code></pre><p>如果们没有设定缓存模式，默认是缓存了Result，而不缓存source,那一定会走到下面这个decode方法。<br>这个decode方法也是接口方法之一，也是通过上面的注册表去寻找对应的实现类。最初找到的是这个类，最后你会发现getDecode里面不断的嵌套这更加基础的类</p>
<pre><code> ImageVideoDataLoadProvider imageVideoDataLoadProvider =
                new ImageVideoDataLoadProvider(streamBitmapLoadProvider, fileDescriptorLoadProvider);
        dataLoadProviderRegistry.register(ImageVideoWrapper.class, Bitmap.class, imageVideoDataLoadProvider);</code></pre><p>最后达到StreamBitmapDataLoadProvider，这个数据解析容器就提供了把Inputstream转化到bitmap里面。这里面的Decoder里面会调用Downsampler，真正的进行解析。</p>
<pre><code>   public Bitmap decode(InputStream is, BitmapPool pool, int outWidth, int outHeight, DecodeFormat decodeFormat) {
        final ByteArrayPool byteArrayPool = ByteArrayPool.get();
        final byte[] bytesForOptions = byteArrayPool.getBytes();
        final byte[] bytesForStream = byteArrayPool.getBytes();
        final BitmapFactory.Options options = getDefaultOptions();

        // Use to fix the mark limit to avoid allocating buffers that fit entire images.
        RecyclableBufferedInputStream bufferedStream = new RecyclableBufferedInputStream(
                is, bytesForStream);
        // Use to retrieve exceptions thrown while reading.
        // TODO(#126): when the framework no longer returns partially decoded Bitmaps or provides a way to determine
        // if a Bitmap is partially decoded, consider removing.
        ExceptionCatchingInputStream exceptionStream =
                ExceptionCatchingInputStream.obtain(bufferedStream);
        // Use to read data.
        // Ensures that we can always reset after reading an image header so that we can still attempt to decode the
        // full image even when the header decode fails and/or overflows our read buffer. See #283.
        MarkEnforcingInputStream invalidatingStream = new MarkEnforcingInputStream(exceptionStream);
        try {
            exceptionStream.mark(MARK_POSITION);
            int orientation = 0;
            try {
                orientation = new ImageHeaderParser(exceptionStream).getOrientation();
            } catch (IOException e) {
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Cannot determine the image orientation from header", e);
                }
            } finally {
                try {
                    exceptionStream.reset();
                } catch (IOException e) {
                    if (Log.isLoggable(TAG, Log.WARN)) {
                        Log.w(TAG, "Cannot reset the input stream", e);
                    }
                }
            }

            options.inTempStorage = bytesForOptions;

            final int[] inDimens = getDimensions(invalidatingStream, bufferedStream, options);
            final int inWidth = inDimens[0];
            final int inHeight = inDimens[1];

            final int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
            final int sampleSize = getRoundedSampleSize(degreesToRotate, inWidth, inHeight, outWidth, outHeight);

            final Bitmap downsampled =
                    downsampleWithSize(invalidatingStream, bufferedStream, options, pool, inWidth, inHeight, sampleSize,
                            decodeFormat);

            // BitmapFactory swallows exceptions during decodes and in some cases when inBitmap is non null, may catch
            // and log a stack trace but still return a non null bitmap. To avoid displaying partially decoded bitmaps,
            // we catch exceptions reading from the stream in our ExceptionCatchingInputStream and throw them here.
            final Exception streamException = exceptionStream.getException();
            if (streamException != null) {
                throw new RuntimeException(streamException);
            }

            Bitmap rotated = null;
            if (downsampled != null) {
                rotated = TransformationUtils.rotateImageExif(downsampled, pool, orientation);

                if (!downsampled.equals(rotated) &amp;&amp; !pool.put(downsampled)) {
                    downsampled.recycle();
                }
            }

            return rotated;
        } finally {
            byteArrayPool.releaseBytes(bytesForOptions);
            byteArrayPool.releaseBytes(bytesForStream);
            exceptionStream.release();
            releaseOptions(options);
        }
    }</code></pre><p>至于里面做了什么请容我稍后和Picasso一起说明。现在只需要明白是通过获取到inputstream，在BitmapFactory.decodeStream解析成为Bitmap的。</p>
<h3 id="Glide-转化和回调"><a href="#Glide-转化和回调" class="headerlink" title="Glide 转化和回调"></a>Glide 转化和回调</h3><p>接着根据我的时序图，可以清楚的知道到了decodeJob里面转化为我们需要的Resource</p>
<pre><code>private Resource&lt;Z&gt; transformEncodeAndTranscode(Resource&lt;T&gt; decoded) {
        long startTime = LogTime.getLogTime();
        Resource&lt;T&gt; transformed = transform(decoded);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logWithTimeAndKey("Transformed resource from source", startTime);
        }

        writeTransformedToCache(transformed);

        startTime = LogTime.getLogTime();
        Resource&lt;Z&gt; result = transcode(transformed);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logWithTimeAndKey("Transcoded transformed from source", startTime);
        }
        return result;
    }</code></pre><p>最后在EngineRunnable方法的run里面进行回调，到了EngineJob里面通过MainHandler进行异步，刷新UI</p>
<pre><code>   public void onResourceReady(final Resource&lt;?&gt; resource) {
        this.resource = resource;
        MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();
    }

    private void handleResultOnMainThread() {
        if (isCancelled) {
            resource.recycle();
            return;
        } else if (cbs.isEmpty()) {
            throw new IllegalStateException("Received a resource without any callbacks to notify");
        }
        engineResource = engineResourceFactory.build(resource, isCacheable);
        hasResource = true;

        // Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it
        // synchronously released by one of the callbacks.
        engineResource.acquire();
        listener.onEngineJobComplete(key, engineResource);

        for (ResourceCallback cb : cbs) {
            if (!isInIgnoredCallbacks(cb)) {
                engineResource.acquire();
                cb.onResourceReady(engineResource);
            }
        }
        // Our request is complete, so we can release the resource.
        engineResource.release();
    }</code></pre><p>这里画一张图来作为理解：</p>
<p><img src="/images/Glide%E8%B4%A3%E4%BB%BB%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Glide联网与解码.png"></p>
<p>到这里Glide的图片加载就完成了。就这点东西？不可能，只有这点东西还不值得我来写文章，毕竟很多人都写过了。先来看看Picasso。</p>
<h1 id="Picasso"><a href="#Picasso" class="headerlink" title="Picasso"></a>Picasso</h1><p>我这边还是以网络加载图片为例子来学习Picasso的源码。先上时序图<br><img src="/images/Picasso%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="Picasso时序图.jpg"></p>
<p>先看看Picasso的用法:</p>
<pre><code>Picasso.with(this).load("url").into(imageview);</code></pre><p>看起来和Glide一模一样，所以经常很多人拿出来和Glide做比对。<br>我先开始他的源码学习之旅，比起看起来头痛欲裂重量级别的Glide，Picasso看起来舒服很多。<br>在这里我先归纳出几个重要的角色，在整个Picasso网络加载图片的流程中。</p>
<p>###Picasso 各个职能</p>
<p><img src="/images/Picasso%E4%B8%BB%E8%A6%81%E8%81%8C%E8%83%BD%E8%A7%92%E8%89%B2.png" alt="Picasso主要职能角色.png"></p>
<p>1.Request 是一次请求，每一次动作开始之前，我们要声明一个请求，设置好对应的资源号，uri等参数。</p>
<p>2.Action 这个是指一次动作。比如说当我们加载图片到ImageView的时候，就会声明一个ImageViewAction，初始化一次动作，每一个动作都会包含一个请求。</p>
<p>3.Dispatcher 是一个分发器。这个分发器的作用如果看过okhttp的源码，你会发现两者之间的思路十分相近。这个分发器是处理各种不同状态的Action，如REQUEST_SUBMIT 网络请求状态，HUNTER_COMPLETE 图片解析完成状态等。</p>
<p>4.ResourceRequestHandler 资源请求处理器。这个和okhttp的拦截器实现起来有点相似都是加入到一个不变的list中，但是实际上不同，每一次判断都会从这个list中轮询其中的处理器，通过canHandleRequest来判断是符合当前请求的情况。</p>
<p>5.BitmapHunter 里面实现了Runnable方法，通过PicassoExecutorService线程池启动其中的run方法，无论是联网还是解析数据都在这里面，可以说这个是Picasso的核心方法。</p>
<h3 id="Picasso-with"><a href="#Picasso-with" class="headerlink" title="Picasso with"></a>Picasso with</h3><p>好了重要角色也差不多了，从with开始，一边分析分析Picasso的源码，一边比较Glide之间的异同。</p>
<pre><code>  public static Picasso with(Context context) {
    if (singleton == null) {
      synchronized (Picasso.class) {
        if (singleton == null) {
          singleton = new Builder(context).build();
        }
      }
    }
    return singleton;
  }

</code></pre><p>这个with很简单，比起Glide来说，简单了很多了。Picasso在with的过程中，仅仅只是通过单例获取Picasso的对象以及获取分发器，缓存，线程等对象，而Glide则是绑定了一个隐形的fragment监听整个生命周期。值得注意的是，Picasso在构造器中注册好了各种类型的ResourceRequestHandler 资源请求处理器，这点和Glide十分相似。</p>
<pre><code>public Picasso build() {
      Context context = this.context;

      if (downloader == null) {
        downloader = Utils.createDefaultDownloader(context);
      }
      if (cache == null) {
        cache = new LruCache(context);
      }
      if (service == null) {
        service = new PicassoExecutorService();
      }
      if (transformer == null) {
        transformer = RequestTransformer.IDENTITY;
      }

      Stats stats = new Stats(cache);

      Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);

      return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,
          defaultBitmapConfig, indicatorsEnabled, loggingEnabled);
    }

Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener,
      RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats,
      Bitmap.Config defaultBitmapConfig, boolean indicatorsEnabled, boolean loggingEnabled) {
    this.context = context;
    this.dispatcher = dispatcher;
    this.cache = cache;
    this.listener = listener;
    this.requestTransformer = requestTransformer;
    this.defaultBitmapConfig = defaultBitmapConfig;

    int builtInHandlers = 7; // Adjust this as internal handlers are added or removed.
    int extraCount = (extraRequestHandlers != null ? extraRequestHandlers.size() : 0);
    List&lt;RequestHandler&gt; allRequestHandlers =
        new ArrayList&lt;RequestHandler&gt;(builtInHandlers + extraCount);

    // ResourceRequestHandler needs to be the first in the list to avoid
    // forcing other RequestHandlers to perform null checks on request.uri
    // to cover the (request.resourceId != 0) case.
    allRequestHandlers.add(new ResourceRequestHandler(context));
    if (extraRequestHandlers != null) {
      allRequestHandlers.addAll(extraRequestHandlers);
    }
    allRequestHandlers.add(new ContactsPhotoRequestHandler(context));
    allRequestHandlers.add(new MediaStoreRequestHandler(context));
    allRequestHandlers.add(new ContentStreamRequestHandler(context));
    allRequestHandlers.add(new AssetRequestHandler(context));
    allRequestHandlers.add(new FileRequestHandler(context));
    allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats));
    requestHandlers = Collections.unmodifiableList(allRequestHandlers);

   ...
  }</code></pre><h3 id="Picasso-load"><a href="#Picasso-load" class="headerlink" title="Picasso load"></a>Picasso load</h3><p>再看看load的方法,这个方法创建一个Request.Builder，用于以后创建Request请求</p>
<pre><code>  public RequestCreator load(String path) {
    if (path == null) {
      return new RequestCreator(this, null, 0);
    }
    if (path.trim().length() == 0) {
      throw new IllegalArgumentException("Path must not be empty.");
    }
    return load(Uri.parse(path));
  }</code></pre><pre><code>  RequestCreator(Picasso picasso, Uri uri, int resourceId) {
    if (picasso.shutdown) {
      throw new IllegalStateException(
          "Picasso instance already shut down. Cannot submit new requests.");
    }
    this.picasso = picasso;
    this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);
  }

  @TestOnly RequestCreator() {
    this.picasso = null;
    this.data = new Request.Builder(null, 0, null);
  }</code></pre><p>picasso的load方法确实简单很多，看来很多逻辑都放在了into之后的步骤。而glide在load的步骤会声明一个GenericRequest，一个FixDataProvider。而这个FixDataProvider在声明的时候，就把需要的数据解析容器全部筛选出来。</p>
<h3 id="Picasso-into"><a href="#Picasso-into" class="headerlink" title="Picasso into"></a>Picasso into</h3><p>接下来再看看Picasso的into方法</p>
<pre><code> public void into(ImageView target, Callback callback) {
    long started = System.nanoTime();
    checkMain();

    if (target == null) {
      throw new IllegalArgumentException("Target must not be null.");
    }

    if (!data.hasImage()) {
      picasso.cancelRequest(target);
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable());
      }
      return;
    }

    if (deferred) {
      if (data.hasSize()) {
        throw new IllegalStateException("Fit cannot be used with resize.");
      }
      int width = target.getWidth();
      int height = target.getHeight();
      if (width == 0 || height == 0) {
        if (setPlaceholder) {
          setPlaceholder(target, getPlaceholderDrawable());
        }
        picasso.defer(target, new DeferredRequestCreator(this, target, callback));
        return;
      }
      data.resize(width, height);
    }

    Request request = createRequest(started);
    String requestKey = createKey(request);

    if (shouldReadFromMemoryCache(memoryPolicy)) {
      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);
      if (bitmap != null) {
        picasso.cancelRequest(target);
        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);
        if (picasso.loggingEnabled) {
          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), "from " + MEMORY);
        }
        if (callback != null) {
          callback.onSuccess();
        }
        return;
      }
    }

    if (setPlaceholder) {
      setPlaceholder(target, getPlaceholderDrawable());
    }

    Action action =
        new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,
            errorDrawable, requestKey, tag, callback, noFade);

    picasso.enqueueAndSubmit(action);
  }</code></pre><p>在这个into的方法中，Picasso做了如下的处理，创建一个Request，以及一个key。如果设置了memoryPolicy，就用来比较LruCache中是否存在对应的key。</p>
<p>接着就设置一个占位图，创建一个action，以及把动作丢给Dispatcher分发器，让它通过调用handler启动线程池去处理这个动作。</p>
<p>###Picasso 联网和decode<br>根据时序图，很容易知道接下来会到达Dispatcher的performSubmit</p>
<pre><code>  void performSubmit(Action action, boolean dismissFailed) {
...
    BitmapHunter hunter = hunterMap.get(action.getKey());
    if (hunter != null) {
      hunter.attach(action);
      return;
    }

    if (service.isShutdown()) {
      if (action.getPicasso().loggingEnabled) {
        log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), "because shut down");
      }
      return;
    }

    hunter = forRequest(action.getPicasso(), this, cache, stats, action);
    hunter.future = service.submit(hunter);
    hunterMap.put(action.getKey(), hunter);

...</code></pre><p>在这里有俩个行为需要特别注意:</p>
<pre><code>    hunter = forRequest(action.getPicasso(), this, cache, stats, action);
    hunter.future = service.submit(hunter);</code></pre><p>1.通过动作创建一个BitmapHunter<br>2.启动线程池子</p>
<p>在第一个方法中</p>
<pre><code>  static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,
      Action action) {
    Request request = action.getRequest();
    List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();

    // Index-based loop to avoid allocating an iterator.
    //noinspection ForLoopReplaceableByForEach
    for (int i = 0, count = requestHandlers.size(); i &lt; count; i++) {
      RequestHandler requestHandler = requestHandlers.get(i);
      if (requestHandler.canHandleRequest(request)) {
        return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);
      }
    }

    return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);
  }</code></pre><p>通过了canHandleRequest来筛选出对应的资源处理器。我们先挑出来NetworkRequestHandler看看该方法</p>
<pre><code>  private static final String SCHEME_HTTP = "http";
  private static final String SCHEME_HTTPS = "https";

  @Override public boolean canHandleRequest(Request data) {
    String scheme = data.uri.getScheme();
    return (SCHEME_HTTP.equals(scheme) || SCHEME_HTTPS.equals(scheme));
  }</code></pre><p>这个是对传进来的String进行uri的判断。来筛选出合适的资源处理器。</p>
<p>第二个方法，则是启动了线程池子<br>接下来我们看看在BitmapHunter中的run方法。而这个run方法又会调用hunt</p>
<pre><code>Bitmap hunt() throws IOException {
    Bitmap bitmap = null;

...

    data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;
//调用NetworkRequestHandler的load联网
    RequestHandler.Result result = requestHandler.load(data, networkPolicy);
    if (result != null) {
      loadedFrom = result.getLoadedFrom();
      exifRotation = result.getExifOrientation();

      bitmap = result.getBitmap();

      // If there was no Bitmap then we need to decode it from the stream.
      if (bitmap == null) {
        InputStream is = result.getStream();
        try {
//解析bitmap
          bitmap = decodeStream(is, data);
        } finally {
          Utils.closeQuietly(is);
        }
      }
    }

    if (bitmap != null) {
      if (picasso.loggingEnabled) {
        log(OWNER_HUNTER, VERB_DECODED, data.logId());
      }
      stats.dispatchBitmapDecoded(bitmap);
      if (data.needsTransformation() || exifRotation != 0) {
        synchronized (DECODE_LOCK) {
          if (data.needsMatrixTransform() || exifRotation != 0) {
            bitmap = transformResult(data, bitmap, exifRotation);
            if (picasso.loggingEnabled) {
              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());
            }
          }
          if (data.hasCustomTransformations()) {
            bitmap = applyCustomTransformations(data.transformations, bitmap);
            if (picasso.loggingEnabled) {
              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), "from custom transformations");
            }
          }
        }
        if (bitmap != null) {
          stats.dispatchBitmapTransformed(bitmap);
        }
      }
    }

    return bitmap;
  }</code></pre><p>关键的两句话已经标记出来了，一个是通过NetworkRequestHandler的load方法联网获取inputstream，一个是通过decodeStream解析成bitmap。<br>我们发现load方法最后会</p>
<pre><code>downloader.load(request.uri, request.networkPolicy);</code></pre><p>而这个Downloader是在构造器时候初始化的，会优先获取okhttp，没有则调用UrlConnectionDownloader。:</p>
<pre><code>  static Downloader createDefaultDownloader(Context context) {
    try {
      Class.forName("com.squareup.okhttp.OkHttpClient");
      return OkHttpLoaderCreator.create(context);
    } catch (ClassNotFoundException ignored) {
    }
    return new UrlConnectionDownloader(context);
  }</code></pre><p>当然，调用okhttp会更好，毕竟okhttp在网络连接上更加的完善，除了几乎一系列的200，304，307等行为。这里我们先看看UrlConnectionDownloader的load方法</p>
<pre><code>  @Override public Response load(Uri uri, int networkPolicy) throws IOException {
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
      installCacheIfNeeded(context);
    }

    HttpURLConnection connection = openConnection(uri);
    connection.setUseCaches(true);

    if (networkPolicy != 0) {
      String headerValue;

      if (NetworkPolicy.isOfflineOnly(networkPolicy)) {
        headerValue = FORCE_CACHE;
      } else {
        StringBuilder builder = CACHE_HEADER_BUILDER.get();
        builder.setLength(0);

        if (!NetworkPolicy.shouldReadFromDiskCache(networkPolicy)) {
          builder.append("no-cache");
        }
        if (!NetworkPolicy.shouldWriteToDiskCache(networkPolicy)) {
          if (builder.length() &gt; 0) {
            builder.append(',');
          }
          builder.append("no-store");
        }

        headerValue = builder.toString();
      }

      connection.setRequestProperty("Cache-Control", headerValue);
    }

    int responseCode = connection.getResponseCode();
    if (responseCode &gt;= 300) {
      connection.disconnect();
      throw new ResponseException(responseCode + " " + connection.getResponseMessage(),
          networkPolicy, responseCode);
    }

    long contentLength = connection.getHeaderFieldInt("Content-Length", -1);
    boolean fromCache = parseResponseSourceHeader(connection.getHeaderField(RESPONSE_SOURCE));

    return new Response(connection.getInputStream(), fromCache, contentLength);
  }</code></pre><p>从这里我们看出这两者处理十分相似。Picasso和Glide一样都是对之前设置设置好的模式都加入到了头里面进行请求。但是接下来就出现了分歧，在Picasso中会获取返回的数据解析头，来判断下一步究竟是要从磁盘中读取还是从流中读取。而glide则是完完全全按照配置来获取流，比如在这一段中，Picasso并没有解析头，而是直接把流传给了下一步。</p>
<p>接下来再看看Picasso对图片的解析</p>
<pre><code>  static Bitmap decodeStream(InputStream stream, Request request) throws IOException {
    MarkableInputStream markStream = new MarkableInputStream(stream);
    stream = markStream;

    long mark = markStream.savePosition(65536); // TODO fix this crap.

    final BitmapFactory.Options options = RequestHandler.createBitmapOptions(request);
    final boolean calculateSize = RequestHandler.requiresInSampleSize(options);

    boolean isWebPFile = Utils.isWebPFile(stream);
    markStream.reset(mark);
    // When decode WebP network stream, BitmapFactory throw JNI Exception and make app crash.
    // Decode byte array instead
    if (isWebPFile) {
      byte[] bytes = Utils.toByteArray(stream);
      if (calculateSize) {
        BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options);
        RequestHandler.calculateInSampleSize(request.targetWidth, request.targetHeight, options,
            request);
      }
      return BitmapFactory.decodeByteArray(bytes, 0, bytes.length, options);
    } else {
      if (calculateSize) {
        BitmapFactory.decodeStream(stream, null, options);
        RequestHandler.calculateInSampleSize(request.targetWidth, request.targetHeight, options,
            request);

        markStream.reset(mark);
      }
      Bitmap bitmap = BitmapFactory.decodeStream(stream, null, options);
      if (bitmap == null) {
        // Treat null as an IO exception, we will eventually retry.
        throw new IOException("Failed to decode stream.");
      }
      return bitmap;
    }
  }</code></pre><p>在这里我们可以清楚：<br>Picasso支持解析WebP格式的图片，这种图片比起常用的png，jpeg来说更小，更省流量，加载更快。而Glide虽然并没有支持WebP但是却支持jpeg，png，gif这几种格式。</p>
<h3 id="Picasso回调和异步刷新UI"><a href="#Picasso回调和异步刷新UI" class="headerlink" title="Picasso回调和异步刷新UI"></a>Picasso回调和异步刷新UI</h3><p>根据我的时序图，可以清晰的明白接下来会通过performComplete调用</p>
<pre><code>private void batch(BitmapHunter hunter) {
    if (hunter.isCancelled()) {
      return;
    }
    batch.add(hunter);
    if (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) {
      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);
    }
  }</code></pre><p>这里由通过Dispatcher 的Handler调用声明在主线程的mainThreadHandler</p>
<pre><code> void performBatchComplete() {
    List&lt;BitmapHunter&gt; copy = new ArrayList&lt;BitmapHunter&gt;(batch);
    batch.clear();
    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));
    logBatch(copy);
  }</code></pre><p>通过主线程调用deliverAction</p>
<pre><code>  private void deliverAction(Bitmap result, LoadedFrom from, Action action) {
    if (action.isCancelled()) {
      return;
    }
    if (!action.willReplay()) {
      targetToAction.remove(action.getTarget());
    }
    if (result != null) {
      if (from == null) {
        throw new AssertionError("LoadedFrom cannot be null.");
      }
      action.complete(result, from);
      if (loggingEnabled) {
        log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), "from " + from);
      }
    } else {
      action.error();
      if (loggingEnabled) {
        log(OWNER_MAIN, VERB_ERRORED, action.request.logId());
      }
    }
  }</code></pre><p>我们回去看看ImageViewAction的complete方法。</p>
<pre><code>  @Override public void complete(Bitmap result, Picasso.LoadedFrom from) {
    if (result == null) {
      throw new AssertionError(
          String.format("Attempted to complete action with no result!\n%s", this));
    }

    ImageView target = this.target.get();
    if (target == null) {
      return;
    }

    Context context = picasso.context;
    boolean indicatorsEnabled = picasso.indicatorsEnabled;
    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);

    if (callback != null) {
      callback.onSuccess();
    }
  }</code></pre><p>这样就把图片刷到了ImageView。至此就把Glide和Picasso的网络加载流程全部解释结束。</p>
<p>这里同样给一张图，作为总结理解：<br><img src="/images/Picasso%E8%81%94%E7%BD%91%E4%B8%8E%E8%A7%A3%E7%A0%81.png" alt="Picasso联网与解码.png"></p>
<p>###Picasso和Glide异同</p>
<p>在这里我针对网上指出的Picasso和Glide比较的博文里面做一下解析，他们经过测试上比较了双方的异同。请原谅我，直接借用他们的文章抛砖引玉。</p>
<p><a href="https://www.jianshu.com/p/fc72001dc18d" target="_blank" rel="noopener">https://www.jianshu.com/p/fc72001dc18d</a><br><a href="http://blog.csdn.net/qq_35166847/article/details/51814409" target="_blank" rel="noopener">http://blog.csdn.net/qq_35166847/article/details/51814409</a></p>
<p>抛开相同的问题，我们通过现象对这些现象做解答。</p>
<p>异同1:Glide加载图片后占用的内存比Picasso占用少。<br>异同2:Glide的加载速度比Picasso慢。<br>异同3:Glide加载的图片一般比Picasso的质量差点。<br>这就要自己看看之前Glide是如何decode整个bitmap的。<br>我们翻上去看看decode的方法。</p>
<pre><code>public Bitmap decode(InputStream is, BitmapPool pool, int outWidth, int outHeight, DecodeFormat decodeFormat) {
        final ByteArrayPool byteArrayPool = ByteArrayPool.get();
        final byte[] bytesForOptions = byteArrayPool.getBytes();
        final byte[] bytesForStream = byteArrayPool.getBytes();
        final BitmapFactory.Options options = getDefaultOptions();

// Use to fix the mark limit to avoid allocating buffers that fit entire images.
        RecyclableBufferedInputStream bufferedStream = new RecyclableBufferedInputStream(
                is, bytesForStream);
        // Use to retrieve exceptions thrown while reading.
        // TODO(#126): when the framework no longer returns partially decoded Bitmaps or provides a way to determine
        // if a Bitmap is partially decoded, consider removing.
        ExceptionCatchingInputStream exceptionStream =
                ExceptionCatchingInputStream.obtain(bufferedStream);
        // Use to read data.
        // Ensures that we can always reset after reading an image header so that we can still attempt to decode the
        // full image even when the header decode fails and/or overflows our read buffer. See #283.
        MarkEnforcingInputStream invalidatingStream = new MarkEnforcingInputStream(exceptionStream);
try {

        options.inTempStorage = bytesForOptions;
        final int[] inDimens = getDimensions(invalidatingStream, bufferedStream, options);
            final int inWidth = inDimens[0];
            final int inHeight = inDimens[1];
...

final Bitmap downsampled =
                    downsampleWithSize(invalidatingStream, bufferedStream, options, pool, inWidth, inHeight, sampleSize,
                            decodeFormat);

...

 Bitmap rotated = null;
            if (downsampled != null) {
                rotated = TransformationUtils.rotateImageExif(downsampled, pool, orientation);

                if (!downsampled.equals(rotated) &amp;&amp; !pool.put(downsampled)) {
                    downsampled.recycle();
                }
            }

            return rotated;

        } finally {
            byteArrayPool.releaseBytes(bytesForOptions);
            byteArrayPool.releaseBytes(bytesForStream);
            exceptionStream.release();
            releaseOptions(options);
        }
}</code></pre><p>Picasso是如何解析的呢？先声明一个MarkableInputStream，这个MarkableInputStream限制了图片解析时候将会占用65536的内存，而超过的时候会报错，这个是2.5.2的bug，而在2.5.2.4b中（网上说不是官方版本），则是做了和Glide一样的处理。<br>Glide 也是自己实现了FliterInputStream：RecyclableBufferedInputStream。这个stream最高限制了5M的大小，初始的时候给了bytesForStream的大小。而这个byte数组是一个长度为1的双端队列。</p>
<pre><code>// 64 KB.
    private static final int TEMP_BYTES_SIZE = 64 * 1024;
    /**
     * Returns a byte array by retrieving one from the pool if the pool is non empty or otherwise by creating a new
     * byte array.
     */
    public byte[] getBytes() {
        byte[] result;
        synchronized (tempQueue) {
            result = tempQueue.poll();
        }
        if (result == null) {
            result = new byte[TEMP_BYTES_SIZE];
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Created temp bytes");
            }
        }
        return result;
    }</code></pre><p>从上面知道我们将会获得一个初始的64kb大小的缓冲区。而这个缓冲区很明显对于加载大图片时候不够用。但是别忘了Glide是读了5遍图片数据流。读取第一次的的时候这个inputstream，每一次读到了极限值的时候，发现没有读完，将会把整个读取极限扩容*2，最后一定足够读完整个流。就是下面这个方法。</p>
<pre><code>    private int fillbuf(InputStream localIn, byte[] localBuf)
            throws IOException {
        if (markpos == -1 || pos - markpos &gt;= marklimit) {
            // Mark position not set or exceeded readlimit
            int result = localIn.read(localBuf);
            if (result &gt; 0) {
                markpos = -1;
                pos = 0;
                count = result;
            }
            return result;
        }
        // Added count == localBuf.length so that we do not immediately double the buffer size before reading any data
        // when marklimit &gt; localBuf.length. Instead, we will double the buffer size only after reading the initial
        // localBuf worth of data without finding what we're looking for in the stream. This allows us to set a
        // relatively small initial buffer size and a large marklimit for safety without causing an allocation each time
        // read is called.
        if (markpos == 0 &amp;&amp; marklimit &gt; localBuf.length &amp;&amp; count == localBuf.length) {
            // Increase buffer size to accommodate the readlimit
            int newLength = localBuf.length * 2;
            if (newLength &gt; marklimit) {
                newLength = marklimit;
            }
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "allocate buffer of length: " + newLength);
            }
            byte[] newbuf = new byte[newLength];
            System.arraycopy(localBuf, 0, newbuf, 0, localBuf.length);
            // Reassign buf, which will invalidate any local references
            // FIXME: what if buf was null?
            localBuf = buf = newbuf;
        } else if (markpos &gt; 0) {
            System.arraycopy(localBuf, markpos, localBuf, 0, localBuf.length
                    - markpos);
        }
        // Set the new position and mark position
        pos -= markpos;
        count = markpos = 0;
        int bytesread = localIn.read(localBuf, pos, localBuf.length - pos);
        count = bytesread &lt;= 0 ? pos : pos + bytesread;
        return bytesread;
    }</code></pre><p>而Picasso之后也做了相似的处理，也是重写了read方法，不断的扩容读取极限。<br>我刚才说的5遍读取数据流又是哪5次呢？这里指出来：</p>
<p>1.获取jpeg图片的信息头exif，这里设计很精妙，每一次读1个字节，一遍解析，一遍获取到自己想要信息。只是调用了数次的inputstream.read()方法。根本不需要读完整个流，加快了获取速度。</p>
<pre><code>orientation = new ImageHeaderParser(exceptionStream).getOrientation();</code></pre><p>2.获取图片的宽高，但是这个时候设置了options.inJustDecodeBounds = true;图片压根没有存到内存里面，仅仅只是获取了图片一些options。</p>
<pre><code>final int[] inDimens = getDimensions(invalidatingStream, bufferedStream, options);
            final int inWidth = inDimens[0];
            final int inHeight = inDimens[1];</code></pre><p>3.根据宽高创建出原始的Bitmap</p>
<pre><code>final Bitmap downsampled =
                    downsampleWithSize(invalidatingStream, bufferedStream, options, pool, inWidth, inHeight, sampleSize,
                            decodeFormat);</code></pre><p>4.是在第三点的时候，判断图片类型，再读了一次头信息</p>
<p>5.根据绘画出来的图片通过画布根据放置方向，方正再一次绘画一次。</p>
<pre><code> Bitmap rotated = null;
            if (downsampled != null) {
                rotated = TransformationUtils.rotateImageExif(downsampled, pool, orientation);

                if (!downsampled.equals(rotated) &amp;&amp; !pool.put(downsampled)) {
                    downsampled.recycle();
                }
            }</code></pre><p>这个即是我们最终所得的图片。</p>
<p>那上面的异同点也可以解释了为什么Glide显示的比Picasso慢，主要因为Glide读了5次流，绘画了2次bitmp，而Picasso只是读了一次流，绘画了一次bitmap。</p>
<p>为什么Glide占用的内存比Picasso小，为什么Glide一般情况下显示的比Picasso的图片质量差：<br>主要是由三点点；<br>1.上述代码可以知道，我们的缓冲区是循环使用的，而Picasso是每一次声明一个缓冲区进行读取流。<br>2.且看下面的代码</p>
<pre><code>    private Bitmap downsampleWithSize(MarkEnforcingInputStream is, RecyclableBufferedInputStream  bufferedStream,
            BitmapFactory.Options options, BitmapPool pool, int inWidth, int inHeight, int sampleSize,
            DecodeFormat decodeFormat) {
        // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
        Bitmap.Config config = getConfig(is, decodeFormat);
        options.inSampleSize = sampleSize;
        options.inPreferredConfig = config;
        if ((options.inSampleSize == 1 || Build.VERSION_CODES.KITKAT &lt;= Build.VERSION.SDK_INT) &amp;&amp; shouldUsePool(is)) {
            int targetWidth = (int) Math.ceil(inWidth / (double) sampleSize);
            int targetHeight = (int) Math.ceil(inHeight / (double) sampleSize);
            // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
            setInBitmap(options, pool.getDirty(targetWidth, targetHeight, config));
        }
        return decodeStream(is, bufferedStream, options);
    }
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    private static void setInBitmap(BitmapFactory.Options options, Bitmap recycled) {
        if (Build.VERSION_CODES.HONEYCOMB &lt;= Build.VERSION.SDK_INT) {
            options.inBitmap = recycled;
        }
    }</code></pre><p>在这里做了options.inBitmap = recycled;的处理，在这里他在options设置了一个复用的Bitmap作为返回的结果bitmap，而这个bitmap复用了LruBitmapPool中规格相同的bitmap，比起Picasso又一次的节约了内存，而越是加载更多的图片，双方之间的内存差越大。</p>
<p>3.在计算SimpleSize采样率上双方采取的策略不一致：<br>先看看Glide：</p>
<pre><code>private int getRoundedSampleSize(int degreesToRotate, int inWidth, int inHeight, int outWidth, int outHeight) {
        int targetHeight = outHeight == Target.SIZE_ORIGINAL ? inHeight : outHeight;
        int targetWidth = outWidth == Target.SIZE_ORIGINAL ? inWidth : outWidth;

        final int exactSampleSize;
        if (degreesToRotate == 90 || degreesToRotate == 270) {
            // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image width is
            // decreased to near our target's height and the image height is decreased to near our target width.
            //noinspection SuspiciousNameCombination
            exactSampleSize = getSampleSize(inHeight, inWidth, targetWidth, targetHeight);
        } else {
            exactSampleSize = getSampleSize(inWidth, inHeight, targetWidth, targetHeight);
        }

/**
     * Load and scale the image uniformly (maintaining the image's aspect ratio) so that the smallest edge of the
     * image will be between 1x and 2x the requested size. The larger edge has no maximum size.
     */
    public static final Downsampler AT_LEAST = new Downsampler() {
        @Override
        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
            return Math.min(inHeight / outHeight, inWidth / outWidth);
        }

        @Override
        public String getId() {
            return "AT_LEAST.com.bumptech.glide.load.data.bitmap";
        }
    };

        // BitmapFactory only accepts powers of 2, so it will round down to the nearest power of two that is less than
        // or equal to the sample size we provide. Because we need to estimate the final image width and height to
        // re-use Bitmaps, we mirror BitmapFactory's calculation here. For bug, see issue #224. For algorithm see
        // http://stackoverflow.com/a/17379704/800716.
        final int powerOfTwoSampleSize = exactSampleSize == 0 ? 0 : Integer.highestOneBit(exactSampleSize);

        // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code than 0.
        return Math.max(1, powerOfTwoSampleSize);
    }

public static final Downsampler AT_MOST = new Downsampler() {
        @Override
        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
            int maxIntegerFactor = (int) Math.ceil(Math.max(inHeight / (float) outHeight,
                inWidth / (float) outWidth));
            int lesserOrEqualSampleSize = Math.max(1, Integer.highestOneBit(maxIntegerFactor));
            return lesserOrEqualSampleSize &lt;&lt; (lesserOrEqualSampleSize &lt; maxIntegerFactor ? 1 : 0);
        }

        @Override
        public String getId() {
            return "AT_MOST.com.bumptech.glide.load.data.bitmap";
        }
    };</code></pre><p>Glide有两种采样率计算模式，<br>默认是第一种AT_LEAST，加载的宽比上实际宽和要加载的高比两者之间去最小，这样能保证在1-2倍。<br>第二种就特殊一点，这里我们可以通过计算得知，Glide是通过要加载的宽比上实际宽和要加载的高比上实际高，去最大并且向上取整，并且去最高位后面极为全部置0.这样做的好处，你总会获取比起到比1倍小，比1/2倍大的数字，这样就限制采样率下限。而outHeight为0的情况不存在的，默认为Integer.MIN_VALUE在Target里面初始化好的默认值，而为0的时候，在onSizeReady就结束了。而为什么只取最高位呢？是因为系统也是这么做，SimpleSize不为2的次幂时候会取成最近的2次幂的采样率。</p>
<p>让我们看看Picasso</p>
<pre><code>static void calculateInSampleSize(int reqWidth, int reqHeight, int width, int height,
      BitmapFactory.Options options, Request request) {
    int sampleSize = 1;
    if (height &gt; reqHeight || width &gt; reqWidth) {
      final int heightRatio;
      final int widthRatio;
      if (reqHeight == 0) {
        sampleSize = (int) Math.floor((float) width / (float) reqWidth);
      } else if (reqWidth == 0) {
        sampleSize = (int) Math.floor((float) height / (float) reqHeight);
      } else {
        heightRatio = (int) Math.floor((float) height / (float) reqHeight);
        widthRatio = (int) Math.floor((float) width / (float) reqWidth);
        sampleSize = request.centerInside
            ? Math.max(heightRatio, widthRatio)
            : Math.min(heightRatio, widthRatio);
      }
    }
    options.inSampleSize = sampleSize;
    options.inJustDecodeBounds = false;
  }</code></pre><p>这个时候，如果我们没有设置宽高，则是默认的SimpleSize为1.而且比出来的结果是向下取整。<br>我们同时可以知道，Picasso的作者偏向还原图片的精致，而Glide的作者更加倾向内存的开销。<br>等一下，不清楚SimpleSize作用的朋友这里提一下，SimlpeSize简单的说就是图片像素的采样点，和视频的码率概念有点像，SimpleSize越高说明采样点越大，相当于几个点当成了一个点显示出来，越低图片越精致。<br>很简单的道理越是同一张图片越是精致占用的内存越高，越是粗糙的图片占用越低。</p>
<p>这里就能解释为什么Glide的图片即使都是在ARGB888下面往往没有Picasso清晰，而Glide占用内存比Picasso低是必然的。</p>
<h3 id="Glide和Picasso缓存策略"><a href="#Glide和Picasso缓存策略" class="headerlink" title="Glide和Picasso缓存策略"></a>Glide和Picasso缓存策略</h3><p>两者之间缓存策略都是内存-磁盘二级缓存机制，如果都没有则去网络下载数据。虽然大方向是相同的，但是细节上略有不同。上面在分析源码的时候已经提到了。</p>
<p>####Picasso缓存策略<br>先说说Picasso的缓存机制，在分析源码已经透露了：<br>into中，在请求每一个Action的时候，都会生成一个key来检测，能存缓存获取到图片，并且去除请求：</p>
<pre><code>    if (shouldReadFromMemoryCache(memoryPolicy)) {
      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);
      if (bitmap != null) {
        picasso.cancelRequest(target);
        target.onBitmapLoaded(bitmap, MEMORY);
        return;
      }
    }</code></pre><p>接着在hunter的run中检测再检测一次缓存是否存在bitmap，</p>
<pre><code>if (shouldReadFromMemoryCache(memoryPolicy)) {
      bitmap = cache.get(key);
      if (bitmap != null) {
        stats.dispatchCacheHit();
        loadedFrom = MEMORY;
        if (picasso.loggingEnabled) {
          log(OWNER_HUNTER, VERB_DECODED, data.logId(), "from cache");
        }
        return bitmap;
      }
    }</code></pre><p>接着在数据回调中，根据网络数据流返回的code，来判断是否从磁盘中获取。在这里，有两个UrlConnectionDownloader和OkHttpDownloader网络连接器。前面是通过HttpResponseCache默认的缓存磁盘缓存，而OkHttpDownloader通过okhttp网络请求的时候，下面的cache拦截器拦截下来，获取磁盘下缓存。</p>
<p>####Glide缓存策略<br>Glide我之前就说过，整个流程是由我们自己完全控制。之前我提到了在Glide中分为缓存分为两种内存和磁盘，这个是在Glide初始化时候完成的工作。</p>
<pre><code>   if (memoryCache == null) {
            memoryCache = new LruResourceCache(calculator.getMemoryCacheSize());
        }

        if (diskCacheFactory == null) {
            diskCacheFactory = new InternalCacheDiskCacheFactory(context);
        }</code></pre><p>前者是内存缓存，后者是磁盘缓存。<br>先看整个流程，和Picasso很相似，<br>1.在创建Request的时候会判断一次，是否已经存在这个Request了，有的话则撤销请求，重新创建一个请求。</p>
<pre><code>Request previous = target.getRequest();

        if (previous != null) {
            previous.clear();
            requestTracker.removeRequest(previous);
            previous.recycle();
        }
</code></pre><p>2.在engine中的load方法，会先判断一次memoryCache是否存在对应request产生出来的key对应的资源文件，有就读出直接返回。</p>
<pre><code> EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);
        if (cached != null) {
            cb.onResourceReady(cached);
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                logWithTimeAndKey("Loaded resource from cache", startTime, key);
            }
            return null;
        }</code></pre><p>这里值得注意的是loadFromCache这个方法：</p>
<pre><code>private final Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;
private EngineResource&lt;?&gt; loadFromCache(Key key, boolean isMemoryCacheable) {
        if (!isMemoryCacheable) {
            return null;
        }

        EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);
        if (cached != null) {
            cached.acquire();
            activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));
        }
        return cached;
    }</code></pre><p>这里的处理策略是，先从LruResourceCache读取缓存中的资源，如果有就从LruResourceCache中移除，并且加入到activeResources中。</p>
<p>3.接下来再尝试从activeResources取出资源文件</p>
<pre><code> EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);
        if (active != null) {
            cb.onResourceReady(active);
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                logWithTimeAndKey("Loaded resource from active resources", startTime, key);
            }
            return null;
        }</code></pre><pre><code>private EngineResource&lt;?&gt; loadFromActiveResources(Key key, boolean isMemoryCacheable) {
        if (!isMemoryCacheable) {
            return null;
        }

        EngineResource&lt;?&gt; active = null;
        WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key);
        if (activeRef != null) {
            active = activeRef.get();
            if (active != null) {
                active.acquire();
            } else {
                activeResources.remove(key);
            }
        }

        return active;
    }</code></pre><p>这么做的好处是什么，首先即使是使用了LruCache最近最少用算法，也无法避免OOM的结果，毕竟加载图片很消耗内存。但是如果把正在使用的资源放在弱引用里面结果就不同了。弱引用相当于打上一个标记，当gc来的时候就会回收掉。一来我正在使用这个资源，即使gc来了，经过分析对象可达性，如果没有使用者也会尝试把这个列表里面的资源全部回收掉。这样就尽量保证了不会出现OOM的情况。</p>
<p>4.如果都没有资源，则从网络尝试获取资源文件在联网之前会先去磁盘缓存里面查看是否还存在key对应的资源，有就从磁盘里面获取。之前那个时序图，是第一次加载图片，所以没有缓存的流程，不然需要一口气看的东西太多了。下面是EngineRunnable的decode方法：</p>
<pre><code> private boolean isDecodingFromCache() {
        return stage == Stage.CACHE;
    }
    private Resource&lt;?&gt; decode() throws Exception {
        if (isDecodingFromCache()) {
            return decodeFromCache();
        } else {
            return decodeFromSource();
        }
    }</code></pre><p>假设已经存到一次图片了：</p>
<pre><code>private Resource&lt;?&gt; decodeFromCache() throws Exception {
        Resource&lt;?&gt; result = null;
        try {
            result = decodeJob.decodeResultFromCache();
        } catch (Exception e) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Exception decoding result from cache: " + e);
            }
        }

        if (result == null) {
            result = decodeJob.decodeSourceFromCache();
        }
        return result;
    }</code></pre><p>这里值得注意的一点，磁盘缓存分为四种下面四种策略:</p>
<pre><code>public enum DiskCacheStrategy {
    /** Caches with both {@link #SOURCE} and {@link #RESULT}. */
    ALL(true, true),
    /** Saves no data to cache. */
    NONE(false, false),
    /** Saves just the original data to cache. */
    SOURCE(true, false),
    /** Saves the media item after all transformations to cache. */
    RESULT(false, true);

    private final boolean cacheSource;
    private final boolean cacheResult;

    DiskCacheStrategy(boolean cacheSource, boolean cacheResult) {
        this.cacheSource = cacheSource;
        this.cacheResult = cacheResult;
    }

    /**
     * Returns true if this request should cache the original unmodified data.
     */
    public boolean cacheSource() {
        return cacheSource;
    }

    /**
     * Returns true if this request should cache the final transformed result.
     */
    public boolean cacheResult() {
        return cacheResult;
    }
}</code></pre><p>source和result两种缓存策略。默认 RESULT(false, true);是只存储经过glide导正和采样之后的图片，而source网上说是没有变形之前的图片，其实还不准确，实际上是没有解析图片之前的从网络获取下来的数据流。</p>
<p>可以看最早的时序图,在解析数据流之前，会判断一次你的缓存策略是什么:</p>
<pre><code>private Resource&lt;T&gt; decodeFromSourceData(A data) throws IOException {
        final Resource&lt;T&gt; decoded;
        if (diskCacheStrategy.cacheSource()) {
            decoded = cacheAndDecodeSourceData(data);
        } else {
            long startTime = LogTime.getLogTime();
            decoded = loadProvider.getSourceDecoder().decode(data, width, height);
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                logWithTimeAndKey("Decoded from source", startTime);
            }
        }
        return decoded;
    }</code></pre><p>比如：</p>
<pre><code>Glide.with(this).load("").diskCacheStrategy(DiskCacheStrategy.ALL).into();</code></pre><p>这个时候会把流和图片一起保存起来，如果第二次加载一样的图片，这个时候就会走到了cacheAndDecodeSourceData的分支里面。</p>
<pre><code>private Resource&lt;T&gt; cacheAndDecodeSourceData(A data) throws IOException {
        long startTime = LogTime.getLogTime();
        SourceWriter&lt;A&gt; writer = new SourceWriter&lt;A&gt;(loadProvider.getSourceEncoder(), data);
        diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logWithTimeAndKey("Wrote source to cache", startTime);
        }

        startTime = LogTime.getLogTime();
        Resource&lt;T&gt; result = loadFromCache(resultKey.getOriginalKey());
        if (Log.isLoggable(TAG, Log.VERBOSE) &amp;&amp; result != null) {
            logWithTimeAndKey("Decoded source from cache", startTime);
        }
        return result;
    }</code></pre><p>这个时候就会把之前产生的key作为键值存入到DiskLruCacheWrapper中，接着再进入到：</p>
<pre><code> private Resource&lt;T&gt; loadFromCache(Key key) throws IOException {
        File cacheFile = diskCacheProvider.getDiskCache().get(key);
        if (cacheFile == null) {
            return null;
        }

        Resource&lt;T&gt; result = null;
        try {
            result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);
        } finally {
            if (result == null) {
                diskCacheProvider.getDiskCache().delete(key);
            }
        }
        return result;
    }</code></pre><p>从磁盘拿出刚才的流，并且解析。这边不多做解释，这个diskCacheProvider最后还是会调用StreamBitmapDataLoadProvider。</p>
<p>当解析好了之后，如果发现磁盘存储策略需要存储result的话，将会在转化的那一步，存入磁盘:</p>
<pre><code> private void writeTransformedToCache(Resource&lt;T&gt; transformed) {
        if (transformed == null || !diskCacheStrategy.cacheResult()) {
            return;
        }
        long startTime = LogTime.getLogTime();
        SourceWriter&lt;Resource&lt;T&gt;&gt; writer = new SourceWriter&lt;Resource&lt;T&gt;&gt;(loadProvider.getEncoder(), transformed);
        diskCacheProvider.getDiskCache().put(resultKey, writer);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logWithTimeAndKey("Wrote transformed from source to cache", startTime);
        }
    }</code></pre><p>别担心会覆盖，因为在每个Request里面都会生成流和资源对应的key。</p>
<p>当然如果获取不到图片会调用LoadFailed，就会修改Stage状态，尝试这区联网去读流：</p>
<pre><code>private void onLoadFailed(Exception e) {
        if (isDecodingFromCache()) {
            stage = Stage.SOURCE;
            manager.submitForSource(this);
        } else {
            manager.onException(e);
        }
    }</code></pre><p>这个时候就是时序图上面的流程了。</p>
<p>到这里Picasso和Glide双方的缓存策略已经全部解释完了。在这里我发现有人总结的图片比我的好，我就借用他的图片了。<br>Picasso缓存策略:<br><img src="/images/Picasso%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.jpg" alt="Picasso缓存策略"></p>
<p>Glide缓存策略：<br><img src="/images/Glide%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.jpg" alt="Glide缓存策略"></p>
<p>Glide的基础部分也分析的差不多了，虽然还有不少的模块还没有解析到，等以后有缘在写吧。</p>
<p>这里要感谢Darren大佬，郭霖大佬以及下面这些博文的作者:<br>缓存图片出处:<a href="http://blog.csdn.net/u011803341/article/details/62434085" target="_blank" rel="noopener">http://blog.csdn.net/u011803341/article/details/62434085</a></p>
<p>Glide和Picasso性能测试出处:<br><a href="https://www.jianshu.com/p/fc72001dc18d" target="_blank" rel="noopener">https://www.jianshu.com/p/fc72001dc18d</a><br><a href="http://blog.csdn.net/qq_35166847/article/details/51814409" target="_blank" rel="noopener">http://blog.csdn.net/qq_35166847/article/details/51814409</a></p>
<p>下面是经过解析之后，结合glide和picasso优点，使用拦截器处理图片流的图片加载库:<br><a href="https://github.com/yjy239/TNLoader">https://github.com/yjy239/TNLoader</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>


            


        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2018/04/05/cong-yuan-ma-jiao-du-kan-asynctask-yu-loadermanager-duo-xian-cheng-she-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="从源码角度看AsyncTask与LoaderManager多线程设计">
                        
                        <span class="card-title">从源码角度看AsyncTask与LoaderManager多线程设计</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            题外话哈，搁置了一段时间没有写博客。主要是去研究Android虚拟机和ffmpeg中ffplay的源码了。计划上是时候把AsyncTask和其中蕴含的多线程编程思想和大家所得分享一下，自己也需要记录一下。之后可能将计划把handler最后一
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2018-04-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Android-Framework/" class="post-category">
                                    Android Framework
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Android/">
                        <span class="chip bg-color">Android</span>
                    </a>
                    
                    <a href="/tags/Android-Framework/">
                        <span class="chip bg-color">Android Framework</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2018/01/02/handler-de-er-ci-wa-jue-he-xue-xi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="Handler的二次挖掘和学习">
                        
                        <span class="card-title">Handler的二次挖掘和学习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            时隔一年，我再一次回头看Handler的源码，发现又有一些东西是我之前没有弄透彻，没有完完全全理解Handler。2年后的今天，还是2年前的今天就都以Handler的解析作为起点开始我的学习之旅吧。Handler的工作流程这里就不多叙述了，
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2018-01-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Android-Framework/" class="post-category">
                                    Android Framework
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Android/">
                        <span class="chip bg-color">Android</span>
                    </a>
                    
                    <a href="/tags/Android-Framework/">
                        <span class="chip bg-color">Android Framework</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: yjy239的博客<br />'
            + '作者: yjy239<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="center-align copy-right">
            <!-- 本站由&nbsp;&copy;<a href="https://github.com/yjy239/yjy239.github.io.git" target="_blank">yjy239</a>&nbsp;基于
            <a href="https://hexo.io/" target="_blank">Hexo</a>&nbsp;的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>&nbsp;主题搭建 -->
            <!-- <br> -->
            <div>&copy;Copyright yjy239的博客</div>
            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">804k</span>&nbsp;字
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="fa fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fa fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            <br>
            <!-- <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span> -->
            <!-- <script>
                var now = new Date();

                function createtime() {
                    var grt = new Date("11/05/2019 00:00:00");
                    now.setTime(now.getTime() + 250);
                    days = (now - grt) / 1000 / 60 / 60 / 24;
                    dnum = Math.floor(days);
                    hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
                    hnum = Math.floor(hours);
                    if (String(hnum).length == 1) {
                        hnum = "0" + hnum;
                    }
                    minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
                    mnum = Math.floor(minutes);
                    if (String(mnum).length == 1) {
                        mnum = "0" + mnum;
                    }
                    seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                    snum = Math.round(seconds);
                    if (String(snum).length == 1) {
                        snum = "0" + snum;
                    }
                    document.getElementById("timeDate").innerHTML = "本站已安全运行 " + dnum + " 天 ";
                    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
                }
                setInterval("createtime()", 250);
            </script> -->
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/yjy239" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>
















    <a href="https://www.jianshu.com/u/3a14616d66ba" class="tooltipped" target="_blank" data-tooltip="关注我的简书: https://www.jianshu.com/u/3a14616d66ba" data-position="top" data-delay="50">
        <i class="fa fa-inverse">简</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 在线聊天工具  洪卫 shw2018 modify 2019.09.17 -->
    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: ""
        });
        daovoice('update');
    </script>
    

    

    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon.min.js" async="async"></script>
    

    
    
    

</body>

</html>
